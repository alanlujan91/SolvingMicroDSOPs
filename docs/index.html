<!DOCTYPE html> 
<html lang="en" xml:lang="en" > 
<head>
  <title>Solution Methods for Microeconomic
Dynamic Stochastic Optimization Problems</title> 
<meta  charset="utf-8" /> 
<meta name="generator" content="TeX4ht (https://tug.org/tex4ht/)" /> 
<meta name="viewport" content="width=device-width,initial-scale=1" /> 
<link rel="stylesheet" type="text/css" href="SolvingMicroDSOPs.css" /> 
<meta name="src" content="SolvingMicroDSOPs.tex"> 
</head><body 
>
<!--l. 18--><p class="noindent" >                                                                   <span 
class="ecrm-0600">SolvingMicroDSOPs, April 3,</span>
<span 
class="ecrm-0600">2024</span>
  <div class="maketitle">
<h2 class="titleHead">Solution Methods for Microeconomic<br />
Dynamic Stochastic Optimization Problems</h2>
<div class="date" >2024-03-27</div>
<span 
class="ecrm-0600"> </span>
 <div class="author" ><span 
class="ecrm-1440">Christopher D. Carroll</span><sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup></div>
<br />
</div>
<!--l. 35--><p class="noindent" ><span 
class="ecrm-1000">Note: The GitHub repo   </span><a 
href="https://github.com/econ-ark/SolvingMicroDSOPs" ><span 
class="ectt-1000">SolvingMicroDSOPs repo</span></a> <span 
class="ecrm-1000">associated with this document contains python code that</span>
<span 
class="ecrm-1000">produces all results, from scratch, except for the last section on indirect inference. The numerical results have</span>
<span 
class="ecrm-1000">been conﬁrmed by showing that the answers that the raw python produces correspond to the answers</span>
<span 
class="ecrm-1000">produced by tools available in the  </span><a 
href="https://econ-ark.org" ><span 
class="ecrm-1000">Econ-ARK</span></a> <span 
class="ecrm-1000">toolkit, more speciﬁcally those in the   </span><a 
href="https://github.com/econ-ark/HARK" ><span 
class="ectt-1000">HARK</span></a> <span 
class="ecrm-1000">which</span>
<span 
class="ecrm-1000">has full  </span><a 
href="https://docs.econ-ark.org" ><span 
class="ecrm-1000">documentation</span></a><span 
class="ecrm-1000">. The MSM results at the end have have been superseded by tools in the</span>
<a 
href="https://github.com/econ-ark/EstimatingMicroDSOPs" ><span 
class="ectt-1000">EstimatingMicroDSOPs repo</span></a><span 
class="ecrm-1000">.</span>
<!--l. 39--><p class="indent" >  <a 
 id="Abstract"></a> <section role="doc-abstract" class="abstract"> 

<!--l. 40--><p class="noindent" > <br 
class="newline" />_____________________________________________________________________________________
<!--l. 40--><p class="noindent" ><span 
class="ecbx-1200">Abstract</span><br 
class="newline" />   <span 
class="ecrm-1095">These notes describe tools for solving microeconomic dynamic stochastic optimization problems,</span>
<span 
class="ecrm-1095">and show how to use those tools for eﬃciently estimating a standard life cycle consumption/saving</span>
<span 
class="ecrm-1095">model using microeconomic data. No attempt is made at a systematic overview of the many possible</span>
<span 
class="ecrm-1095">technical choices; instead, I present a speciﬁc set of methods that have proven useful in my own work</span>
<span 
class="ecrm-1095">(and explain why other popular methods, such as value function iteration, are a bad idea). Paired</span>
<span 
class="ecrm-1095">with these notes is </span><span 
class="ecti-1095">Mathematica</span><span 
class="ecrm-1095">, Matlab, and Python software that solves the problems described in</span>
<span 
class="ecrm-1095">the text.   </span><br 
class="newline" />
        <blockquote class="quote">
                     <dl class="list2"><dt class="list">
<span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> Keywords</span><span 
class="ecbx-1200"> </span></dt><dd 
class="list">
                 <!--l. 42--><p class="noindent" >Dynamic  Stochastic  Optimization,  Method  of  Simulated
                   Moments, Structural Estimation, Indirect Inference
                   </dd><dt class="list">
<span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> </span><span 
class="ecbx-1200"> JEL codes</span><span 
class="ecbx-1200"> </span></dt><dd 
class="list">
                 <!--l. 42--><p class="noindent" >E21, F41</dd></dl>
                                                                                     
                                                                                     
      </blockquote>
</section>
<div class="center" 
>
<!--l. 45--><p class="noindent" >
<table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> PDF:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf" class="url" ><span 
class="ectt-1000">https://github.com/llorracc/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs.pdf</span></a>
</td></tr></table>
<!--l. 47--><p class="noindent" ><table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> Slides:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/\owner /SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf" class="url" ><span 
class="ectt-1000">https://github.com/\owner/SolvingMicroDSOPs/blob/master/SolvingMicroDSOPs-Slides.pdf</span></a></td></tr></table>
<!--l. 48--><p class="noindent" >                                  <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> Web:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://\owner .github.io/SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://\owner.github.io/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 49--><p class="noindent" >                <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> Code:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/\owner /SolvingMicroDSOPs/tree/master/Code" class="url" ><span 
class="ectt-1000">https://github.com/\owner/SolvingMicroDSOPs/tree/master/Code</span></a></td></tr></table>
<!--l. 50--><p class="noindent" >                                 <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000">Archive:</span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><a 
href="https://github.com/\owner /SolvingMicroDSOPs" class="url" ><span 
class="ectt-1000">https://github.com/\owner/SolvingMicroDSOPs</span></a></td></tr></table>
<!--l. 51--><p class="noindent" >     <table  
cellpadding="0" border="0"  
class="tabbing"><tr  
style="vertical-align:baseline;" class="tabbing"><td style="width:75;" 
class="tabbing"><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000"> </span><span 
class="ectt-1000">  </span></td><td  
class="tabbing"></td><td  
class="tabbing"><span 
class="ecti-1000">(Contains LaTeX code for this document and software producing ﬁgures and results)</span></td></tr></table>
<!--l. 53--><p class="noindent" >
</div>
<!--l. 60--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
<!--l. 62--><p class="indent" >  <span class="footnote-mark"><sup class="textsuperscript"></sup></span>
      <sup class="textsuperscript"></sup>
<!--l. 59--><p class="indent" >  <sup class="textsuperscript"><span 
class="ecrm-0600">1</span></sup><span 
class="ecrm-1000">Carroll: Department of Economics, Johns Hopkins University, Baltimore, MD,   </span><a 
href="mailto:ccarroll@jhu.edu" ><span 
class="ectt-1000">ccarroll@jhu.edu</span></a><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span><span 
class="ecrm-1000"> </span>
      <sup class="textsuperscript"></sup><span 
class="ecrm-1000">The  notes  were  originally  written  for  my  Advanced  Topics  in  Macroeconomic  Theory</span>
<span 
class="ecrm-1000">class   at   Johns   Hopkins   University;   instructors   elsewhere   are   welcome   to   use   them   for</span>
<span 
class="ecrm-1000">teaching  purposes.  Relative  to  earlier  drafts,  this  version  incorporates  several  improvements</span>
<span 
class="ecrm-1000">related   to   new   results   in   the   paper     </span><a 
href="http://econ-ark.github.io/BufferStockTheory" ><span 
class="ecrm-1000">“Theoretical   Foundations   of   Buﬀer   Stock   Saving”</span></a>
<span 
class="ecrm-1000">(especially  tools  for  approximating  the  consumption  and  value  functions).  Like  the  last  major</span>
<span 
class="ecrm-1000">draft,   it   also   builds   on   material   in   “The   Method   of   Endogenous   Gridpoints   for   Solving</span>
<span 
class="ecrm-1000">Dynamic   Stochastic   Optimization   Problems”   published   in   </span><span 
class="ecti-1000">Economics   Letters</span><span 
class="ecrm-1000">,   available   at</span>
<a 
href="http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/EndogenousArchive.zip</span></a><span 
class="ecrm-1000">,  and  by  including  sample</span>
<span 
class="ecrm-1000">code for a method of simulated moments estimation of the life cycle model </span><span 
class="ecti-1000">a la </span><span 
class="ecbx-1000">? </span><span 
class="ecrm-1000">and Cagetti</span><span 
class="ecrm-1000"> (</span><span 
class="ecbx-1000">?</span><span 
class="ecrm-1000">).</span>
<span 
class="ecrm-1000">Background derivations, notation, and related subjects are treated in my class notes for ﬁrst year macro,</span>
<span 
class="ecrm-1000">available  at  </span><a 
href="http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption" class="url" ><span 
class="ectt-1000">http://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption</span></a><span 
class="ecrm-1000">.  I</span>
<span 
class="ecrm-1000">am grateful to several generations of graduate students in helping me to reﬁne these notes, to Marc</span>
<span 
class="ecrm-1000">Chan for help in updating the text and software to be consistent with </span><span 
class="ecbx-1000">?</span><span 
class="ecrm-1000">, to Kiichi Tokuoka for drafting</span>
<span 
class="ecrm-1000">the section on structural estimation, to Damiano Sandri for exceptionally insightful help in revising and</span>
<span 
class="ecrm-1000">updating the method of simulated moments estimation section, and to Weifeng Wu and Metin Uyanik</span>
<span 
class="ecrm-1000">for revising to be consistent with the ‘method of moderation’ and other improvements. All errors are</span>
<span 
class="ecrm-1000">my own. This document can be cited as </span><span 
class="ecbx-1000">? </span><span 
class="ecrm-1000">in the references.</span>
                                                                                     
                                                                                     
<!--l. 71--><p class="indent" >  <a 
 id="Introduction"></a>
  <h3 class="sectionHead"><span class="titlemark">1  </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 93--><p class="noindent" >These lecture notes provide a gentle introduction to a particular set of solution tools for the
canonical consumption-saving/portfolio allocation problem. Speciﬁcally, the notes describe and
solve optimization problems for a consumer facing uninsurable idiosyncratic risk to nonﬁnancial
income (e.g., labor or transfer income), ﬁrst without and then with optimal portfolio
choice,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs2.html#fn1x0"><sup class="textsuperscript">1</sup></a></span><a 
 id="x1-1001f1"></a>  
with detailed intuitive discussion of the various mathematical and computational techniques
that, together, speed the solution by many orders of magnitude compared to “brute force”
methods. The problem is solved with and without liquidity constraints, and the inﬁnite
horizon solution is obtained as the limit of the ﬁnite horizon solution. After the basic
consumption/saving problem with a deterministic interest rate is described and
solved, an extension with portfolio choice between a riskless and a risky asset is
also solved. Finally, a simple example shows how to use these methods (via the
statistical ‘method of simulated moments’ (‘MSM’) to estimate structural parameters
like the coeﬃcient of relative risk aversion (<span 
class="ecti-1200">a la </span>Gourinchas and Parker (<span 
class="ecbx-1200">?</span>) and
Cagetti (<span 
class="ecbx-1200">?</span>)).
<!--l. 119--><p class="indent" >  <a 
 id="the-problem"></a>
  <h3 class="sectionHead"><span class="titlemark">2  </span> <a 
 id="x1-20002"></a>The Problem</h3>                                                                      <span 
class="ecrm-0600">{sec:the-problem}</span>
<!--l. 1--><p class="noindent" >The usual analysis of dynamic stochastic programming problems packs a great many events
(intertemporal choice, stochastic shocks, intertemporal returns, income growth, the
taking of expectations, and more) into a single step in which the agent makes an
optimal choice taking account of all of these elements. For the detailed analysis
here, we will be careful to disarticulate everything that happens in the problem
explicitly into separate steps so that each element can be scrutinized and understood in
isolation.
<!--l. 3--><p class="indent" >  We are interested in the behavior a consumer who begins period <img 
src="SolvingMicroDSOPs0x.svg" alt="t  " class="math";align="absmiddle"> with a certain amount
of ‘capital’ <img 
src="SolvingMicroDSOPs1x.svg" alt="kt  " class="math";align="absmiddle">, which is immediately rewarded by a return factor <img 
src="SolvingMicroDSOPs2x.svg" alt="Rt  " class="math";align="absmiddle"> with the proceeds
deposited in a <span 
class="ecbx-1200">b</span>ank account <span 
class="ecbx-1200">b</span>alance:
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs3x.svg" alt="bt = ktRt.
" class="math-display" ><a 
 id="x1-2001r1"></a></div>
  </td><td class="equation-label">(1)</td></tr></table>
<!--l. 6--><p class="nopar" >
<!--l. 9--><p class="indent" >  Simultaneously with the realization of the capital return, the consumer also receives
noncapital income <img 
src="SolvingMicroDSOPs4x.svg" alt="yt  " class="math";align="absmiddle">, which is determined by multiplying the consumer’s ‘permanent
income’ <img 
src="SolvingMicroDSOPs5x.svg" alt="pt  " class="math";align="absmiddle"> by a transitory shock <img 
src="SolvingMicroDSOPs6x.svg" alt="𝜃t  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs7x.svg" alt="yt = pt𝜃t
" class="math-display" ><a 
 id="x1-2002r2"></a></div>
  </td><td class="equation-label">(2)</td></tr></table>
<!--l. 12--><p class="nopar" >whose whose expectation is 1 (that is, before realization of the transitory shock, the
consumer’s expectation is that actual income will on average be equal to permanent income
<img 
src="SolvingMicroDSOPs8x.svg" alt="pt  " class="math";align="absmiddle">).
<!--l. 15--><p class="indent" >  The combination of bank balances <img 
src="SolvingMicroDSOPs9x.svg" alt="b  " class="math";align="absmiddle"> and income <img 
src="SolvingMicroDSOPs10x.svg" alt="y  " class="math";align="absmiddle"> deﬁne’s the consumer’s ‘market
resources’ (sometimes called ‘cash-on-hand,’ following <span 
class="ecbx-1200">?</span>):
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs11x.svg" alt="mt =  bt + yt,
" class="math-display" ><a 
 id="x1-2003r3"></a></div>
  </td><td class="equation-label">(3)</td></tr></table>
<!--l. 18--><p class="nopar" >available to be spent on consumption <img 
src="SolvingMicroDSOPs12x.svg" alt="ct  " class="math";align="absmiddle"> for a consumer subject to a liquidity constraint that
requires <img 
src="SolvingMicroDSOPs13x.svg" alt="c ≤ m  " class="math";align="absmiddle">.
                                                                                     
                                                                                     
<!--l. 21--><p class="indent" >  The consumer’s goal is to maximize discounted utility from consumption over the rest of a
lifetime ending at date <img 
src="SolvingMicroDSOPs14x.svg" alt="T  " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs15x.svg" alt="        [T −t          ]
max  𝔼   ∑   βnu (c   ) .
       t           t+n
          n=0
" class="math-display" ><a 
 id="x1-2004r4"></a></div>
  </td><td class="equation-label">(4)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 154--><p class="indent" >  Income evolves according to:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs16x.svg" alt="            pt+1 = 𝒢t+1pt   -permanent   labor income  dynamics
log  𝜃   ∼  𝒩  (− σ2 ∕2,σ2)  -lognormal  transitory shocks ∀ n &#x003E;  0.
     t+n           𝜃    𝜃
" class="math-display" ><a 
 id="x1-2005r5"></a></div>
  </td><td class="equation-label">(5)</td></tr></table>
<!--l. 5--><p class="nopar" >
<!--l. 165--><p class="indent" >  Equation (<a 
href="#x1-2005r5">5<!--tex4ht:ref: eq:permincgrow --></a>) indicates that we are allowing for a predictable average proﬁle of income
growth over the lifetime <img 
src="SolvingMicroDSOPs17x.svg" alt="    T
{𝒢 }0   " class="math";align="absmiddle"> (to capture typical career wage paths, pension arrangements,
etc).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs3.html#fn2x0"><sup class="textsuperscript">2</sup></a></span><a 
 id="x1-2006f2"></a>  
Finally, the utility function is of the Constant Relative Risk Aversion (CRRA), form,
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs18x.svg" alt="         1− ρ
u(∙ ) = ∙   ∕(1 − ρ )  " class="math";align="absmiddle">.
<!--l. 168--><p class="indent" >  It is well known that this problem can be rewritten in recursive (Bellman) form
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs19x.svg" alt="vt(mt, pt) = macxt  u(ct) + β 𝔼t[vt+1 (mt+1, pt+1)]
" class="math-display" ><a 
 id="x1-2008r6"></a></div>
  </td><td class="equation-label">(6)</td></tr></table>
<!--l. 5--><p class="nopar" >subject to the Dynamic Budget Constraint (DBC) implicitly deﬁned by equations (<a 
href="#x1-2001r1">1<!--tex4ht:ref: eq:bLvl --></a>)-(<a 
href="#x1-2003r3">3<!--tex4ht:ref: eq:mLvl --></a>) and
to the transition equation that deﬁnes next period’s initial capital as this period’s
end-of-period assets:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs20x.svg" alt="kt+1 = at.
" class="math-display" ><a 
 id="x1-2009r7"></a></div>
  </td><td class="equation-label">(7)</td></tr></table>
<!--l. 181--><p class="nopar" >
<!--l. 183--><p class="indent" >  <a 
 id="Normalization"></a>
  <h3 class="sectionHead"><span class="titlemark">3  </span> <a 
 id="x1-30003"></a>Normalization</h3>                                                                     <span 
class="ecrm-0600">{sec:normalization}</span>
<!--l. 185--><p class="noindent" >The single most powerful method for speeding the solution of such models is to redeﬁne the
problem in a way that reduces the number of state variables (if at all possible). Here, the
obvious idea is to see whether the problem can be rewritten in terms of the ratio of various
variables to permanent noncapital (‘labor’) income <img 
src="SolvingMicroDSOPs21x.svg" alt="pt  " class="math";align="absmiddle"> (henceforth for brevity, ‘permanent
income.’)
<!--l. 189--><p class="indent" >  In the last period of life, there is no future, <img 
src="SolvingMicroDSOPs22x.svg" alt="v     = 0
  T+1  " class="math";align="absmiddle">, so the optimal plan is to consume
everything:
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs23x.svg" alt="               m1 −ρ
vT (mT ,pT ) = --T--.
               1 − ρ
" class="math-display" ><a 
 id="x1-3001r8"></a></div>
  </td><td class="equation-label">(8)</td></tr></table>
<!--l. 196--><p class="nopar" >Now deﬁne nonbold variables as the bold variable divided by the level of permanent
income in the same period, so that, for example, <img 
src="SolvingMicroDSOPs24x.svg" alt="mT  =  mT ∕pT  " class="math";align="absmiddle">; and deﬁne
<img 
src="SolvingMicroDSOPs25x.svg" alt="vT (mT ) = u(mT )  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs4.html#fn3x0"><sup class="textsuperscript">3</sup></a></span><a 
 id="x1-3002f3"></a>  
For our CRRA utility function, <img 
src="SolvingMicroDSOPs28x.svg" alt="u(xy) = x1−ρu (y )  " class="math";align="absmiddle">, so (<a 
href="#x1-3001r8">8<!--tex4ht:ref: eq:levelTm1 --></a>) can be rewritten as
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs29x.svg" alt="                      1− ρ
                1−ρ m-T---
vT (mT ,pT ) = pT   1 − ρ
                             1−ρ
             = (pT− 1𝒢T)1−ρm-T---
                           1 − ρ
             = p1−ρ 𝒢1−ρv  (m  ).
                T −1 T   T   T
" class="math-display" ><a 
 id="x1-3004r9"></a></div>
  </td><td class="equation-label">(9)</td></tr></table>
<!--l. 206--><p class="nopar" >
<!--l. 208--><p class="indent" >  Now deﬁne a new optimization problem:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs30x.svg" alt="vt(mt ) = max  u (ct) + β 𝔼t[𝒢1 −ρvt+1(mt+1)]
           ct                t+1
      s.t.

     at = mt − ct
  kt+1 = at

   bt+1 = (◟R-∕𝒢◝t◜+1)◞kt+1
           ≡ℛt+1

  mt+1 = bt+1 + 𝜃t+1,
" class="math-display" ><a 
 id="x1-3005r10"></a></div>
  </td><td class="equation-label">(10)</td></tr></table>
<!--l. 9--><p class="nopar" >where the last equation is the normalized version of the transition equation for
<img 
src="SolvingMicroDSOPs31x.svg" alt="mt+1   " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs5.html#fn4x0"><sup class="textsuperscript">4</sup></a></span><a 
 id="x1-3006f4"></a>  
Then it is easy to see that for <img 
src="SolvingMicroDSOPs33x.svg" alt="t = T − 1  " class="math";align="absmiddle">,
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs34x.svg" alt="                      1−ρ
vT −1(mT −1,pT −1) = pT− 1vT−1(mT −1)
" class="math-display" ></div>
                                                                                     
                                                                                     
  </td></tr></table>
<!--l. 230--><p class="nopar" >and so on back to all earlier periods. Hence, if we solve the problem (<a 
href="#x1-3005r10">10<!--tex4ht:ref: eq:vNormed --></a>) which (when
optimal consumption is being chosen) has only a single state variable <img 
src="SolvingMicroDSOPs35x.svg" alt="mt  " class="math";align="absmiddle">, we can
obtain the levels of the value function, consumption, and all other variables from the
corresponding permanent-income-normalized solution objects by multiplying each by <img 
src="SolvingMicroDSOPs36x.svg" alt="pt  " class="math";align="absmiddle">,
e.g. <img 
src="SolvingMicroDSOPs37x.svg" alt="ccct(mt, pt) = ptct(mt ∕pt)  " class="math";align="absmiddle"> (or, for the value function, <img 
src="SolvingMicroDSOPs38x.svg" alt="              1− ρ
vt(mt, pt) = p t  vt(mt ))  " class="math";align="absmiddle">. We have
thus reduced the problem from two continuous state variables to one (and thereby enormously
simpliﬁed its solution).
<!--l. 238--><p class="indent" >  For some problems it will not be obvious that there is an appropriate ‘normalizing’ variable,
but many problems can be normalized if suﬃcient thought is given. For example, <span 
class="ecbx-1200">? </span>shows
how a bank’s optimization problem can be normalized by the level of the bank’s
productivity.
<!--l. 244--><p class="indent" >  <a 
 id="The-Usual-Theory"></a>
  <h3 class="sectionHead"><span class="titlemark">4  </span> <a 
 id="x1-40004"></a>The Usual Theory, and A Bit More Notation</h3>                                      <span 
class="ecrm-0600">{sec:usualtheory}</span>
<!--l. 248--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">4.1  </span> <a 
 id="x1-50004.1"></a>Steps</h4>
<!--l. 253--><p class="noindent" >Generically, we want to think of the Bellman problem itself as having three steps:
      <ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-5002x1">
      <!--l. 255--><p class="noindent" ><span 
class="ecbx-1200">Arrival</span>: Incoming state variables (e.g., <img 
src="SolvingMicroDSOPs39x.svg" alt="kt  " class="math";align="absmiddle">) are known, but any shocks associated
      with the period have not been realized and decision(s) have not yet been made
      </li>
<li 
  class="enumerate" id="x1-5004x2">
      <!--l. 256--><p class="noindent" ><span 
class="ecbx-1200">Decision</span>:  All  exogenous  variables  (like  income  shocks,  rate  of  return  shocks,
      predictable income growth <img 
src="SolvingMicroDSOPs40x.svg" alt="𝒢 " class="math";align="absmiddle"> have been realized (so that, e.g., <img 
src="SolvingMicroDSOPs41x.svg" alt="mt  " class="math";align="absmiddle">’s value is
      known) and the agent solves the optimization problem
      </li>
<li 
  class="enumerate" id="x1-5006x3">
      <!--l. 257--><p class="noindent" ><span 
class="ecbx-1200">Continuation</span>: After all decisions have been made, it is possible to calculate the
      consequences of the decision, taking as given the ‘outgoing’ state variables (e.g.,
      <img 
src="SolvingMicroDSOPs42x.svg" alt="a  " class="math";align="absmiddle">) – sometimes called ‘post-state’ variables.</li></ol>
                                                                                     
                                                                                     
<!--l. 260--><p class="indent" >  The (implicit) default assumption is often to think of the step of the problem
where the agent is solving a decision problem as deﬁning the unique moment at
which the problem is deﬁned. This is what implicitly was done above, when (for
example) in (<a 
href="#x1-3005r10">10<!--tex4ht:ref: eq:vNormed --></a>) we related current value <img 
src="SolvingMicroDSOPs43x.svg" alt="v
 t  " class="math";align="absmiddle"> to the expectation of future value
<img 
src="SolvingMicroDSOPs44x.svg" alt="vt+1   " class="math";align="absmiddle">.
<!--l. 262--><p class="indent" >  When we want to refer to a speciﬁc step within period <img 
src="SolvingMicroDSOPs45x.svg" alt="t  " class="math";align="absmiddle"> we will do so by preceding it by
an indicator character:
<div class="center" 
>
<!--l. 263--><p class="noindent" >
<!--l. 271--><p class="noindent" > <div class="pic-tabular"><img 
src="SolvingMicroDSOPs46x.svg" alt="         Step  |  Indicator   |Usage   |Explanation
---------------|--------------|--------|----------------------------------------
       Arrival |     ←        |v←t (kt) |value of entering t (before shocks )
     Decision  |(blank/none ) |vt(mt ) |value of t- decision (after shocks)
 Continuation  |     →        |vt→ (at) |value of outgoing state (after decision)  " ></div> </div>
<!--l. 275--><p class="indent" >  This notation allows us to capture the fact that the value of the consumer’s circumstances
can be computed at any of the three steps (and is a function of a diﬀerent state variable at
each step).
<!--l. 277--><p class="indent" >  Note that there is no need to use these subscripts for the model’s variables; while a variable
like <img 
src="SolvingMicroDSOPs47x.svg" alt="at = mt −  ct  " class="math";align="absmiddle"> takes on its value in the transition from the Decision to the Continuation
step, <img 
src="SolvingMicroDSOPs48x.svg" alt="a  " class="math";align="absmiddle"> will have only one unique value over the course of the period and therefore a notation
like <img 
src="SolvingMicroDSOPs49x.svg" alt="a
  ←t  " class="math";align="absmiddle"> would be useless because the variable does not have a value until the continuation
step is reached. Each variable in our problem has a unique value deﬁned at some point during
the period, so there is no ambiguity in referring to them with normal notation like
<img 
src="SolvingMicroDSOPs50x.svg" alt="at  " class="math";align="absmiddle">.
<!--l. 279--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">4.2  </span> <a 
 id="x1-60004.2"></a>The Usual Theory</h4>
<!--l. 281--><p class="noindent" >Using this new notation, the ﬁrst order condition for (<a 
href="#x1-3005r10">10<!--tex4ht:ref: eq:vNormed --></a>) with respect to <img 
src="SolvingMicroDSOPs51x.svg" alt="ct  " class="math";align="absmiddle"> is
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs52x.svg" alt="  c                  1− ρ m
u (ct) = 𝔼t→[βℛt+1 𝒢 t+1 vt+1 (mt+1 )]
      =  𝔼t→[βR    𝒢 t+−1ρvmt+1(mt+1)]
" class="math-display" ><a 
 id="x1-6001r11"></a></div>
                                                                                     
                                                                                     
  </td><td class="equation-label">(11)</td></tr></table>
<!--l. 285--><p class="nopar" >and because the  <a 
href="https://www.econ2.jhu.edu/people/ccarroll/public/lecturenotes/consumption/Envelope" ><span 
class="ectt-1200">Envelope</span></a> theorem tells us that
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs53x.svg" alt="  m                −ρ  m
v t (mt ) = 𝔼←t[βR 𝒢t+1vt+1(mt+1)]
" class="math-display" ><a 
 id="x1-6002r12"></a></div>
  </td><td class="equation-label">(12)</td></tr></table>
<!--l. 289--><p class="nopar" >we can substitute the LHS of (<a 
href="#x1-6002r12">12<!--tex4ht:ref: eq:envelope --></a>) for the RHS of (<a 
href="#x1-6001r11">11<!--tex4ht:ref: eq:upceqEvtp1 --></a>) to get
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs54x.svg" alt="uc(ct) = vmt (mt )
" class="math-display" ><a 
 id="x1-6003r13"></a></div>
  </td><td class="equation-label">(13)</td></tr></table>
<!--l. 3--><p class="nopar" >and rolling forward one period,
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs55x.svg" alt=" c          m
u (ct+1 ) = v t+1(atℛt+1 + 𝜃t+1)
" class="math-display" ><a 
 id="x1-6004r14"></a></div>
  </td><td class="equation-label">(14)</td></tr></table>
<!--l. 301--><p class="nopar" >and substituting the LHS in equation (<a 
href="#x1-6001r11">11<!--tex4ht:ref: eq:upceqEvtp1 --></a>) ﬁnally gives us the Euler equation for
consumption:
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs56x.svg" alt="uc(c ) = 𝔼   [βR 𝒢− ρuc(c   )].
    t     t→     t+1    t+1
" class="math-display" ><a 
 id="x1-6005r15"></a></div>
  </td><td class="equation-label">(15)</td></tr></table>
<!--l. 3--><p class="nopar" >
<!--l. 317--><p class="indent" >  For future reference, it may be useful here to write the distinct value functions at each step
(using the transition equations from (<a 
href="#x1-3005r10">10<!--tex4ht:ref: eq:vNormed --></a>)):
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs57x.svg" alt="                 ◜--=◞m◟t--◝
v←t(kt) = 𝔼←t [vt(ktℛt + 𝜃t)]
" class="math-display" ><a 
 id="x1-6006r16"></a></div>
  </td><td class="equation-label">(16)</td></tr></table>
<!--l. 3--><p class="nopar" >
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs58x.svg" alt="                            at
                         ◜--◞◟-◝
vt(mt) = u(ct(mt )) + vt→(mt −  ct)
" class="math-display" ><a 
 id="x1-6007r17"></a></div>
  </td><td class="equation-label">(17)</td></tr></table>
<!--l. 3--><p class="nopar" >and
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs59x.svg" alt="vt→ (at) = βv ←t+1(kt+1)
                  ◟◝◜◞
                   =at
" class="math-display" ><a 
 id="x1-6008r18"></a></div>
  </td><td class="equation-label">(18)</td></tr></table>
<!--l. 3--><p class="nopar" >where the last line illustrates the notation for addressing the beginning step of the successor
period.
<!--l. 342--><p class="indent" >  Putting all this together, from the perspective of the beginning of period <img 
src="SolvingMicroDSOPs60x.svg" alt="t + 1  " class="math";align="absmiddle"> we can
write the ‘arrival value’ function and its ﬁrst derivative as
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs61x.svg" alt="                       1−ρ
v←t+1(kt+1) = 𝔼←t+1 [ 𝒢t+1vt+1(ℛt+1kt + 𝜃t+1)]
vkt+1(kt+1) = 𝔼←t+1 [R 𝒢t−+ρ1vmt+1(mt+1 )]
 ←
" class="math-display" ><a 
 id="x1-6009r19"></a></div>
  </td><td class="equation-label">(19)</td></tr></table>
<!--l. 4--><p class="nopar" >because they return the expected <img 
src="SolvingMicroDSOPs62x.svg" alt="t + 1  " class="math";align="absmiddle"> value and marginal value associated with arriving in
period <img 
src="SolvingMicroDSOPs63x.svg" alt="t + 1  " class="math";align="absmiddle"> with any given amount of <span 
class="ecbx-1200">k</span>apital. Finally, note for future use that since
<img 
src="SolvingMicroDSOPs64x.svg" alt="kt+1 = at  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs65x.svg" alt="vt→ (at) = βv←t+1(kt+1)  " class="math";align="absmiddle">, the ﬁrst order condition (<a 
href="#x1-6001r11">11<!--tex4ht:ref: eq:upceqEvtp1 --></a>) can now be rewritten
compactly as
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs66x.svg" alt=" c        a
u (ct) = v t→ (mt − ct).
" class="math-display" ><a 
 id="x1-6010r20"></a></div>
  </td><td class="equation-label">(20)</td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 386--><p class="indent" >  <a 
 id="Solving-the-Next-To-Last-Period"></a>
  <h3 class="sectionHead"><span class="titlemark">5  </span> <a 
 id="x1-70005"></a>Solving the Next-to-Last Period</h3>                                                   <span 
class="ecrm-0600">{sec:NextToLast}</span>
<!--l. 392--><p class="noindent" >For convenience assuming that <img 
src="SolvingMicroDSOPs67x.svg" alt="𝒢 =  1  " class="math";align="absmiddle"> so that the <img 
src="SolvingMicroDSOPs68x.svg" alt="𝒢 " class="math";align="absmiddle"> terms disappear from the earlier
derivations, the problem in the second-to-last period of life can now be expressed
as
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs69x.svg" alt="                                       ⌊                           ⌋

vT−1(mT −1) = max   u (cT −1) + β 𝔼T −1 ⌈vT ((mT −1 − cT−1)ℛT  + 𝜃T)⌉ ,
               cT−1                   →      ◟---------◝◜---------◞
                                                      mT
" class="math-display" ></div>
  </td></tr></table>
<!--l. 396--><p class="nopar" >where <img 
src="SolvingMicroDSOPs70x.svg" alt="𝔼T −1→ " class="math";align="absmiddle"> indicates that the expectation is taken as of the end of period <img 
src="SolvingMicroDSOPs71x.svg" alt="T − 1  " class="math";align="absmiddle">.
<!--l. 399--><p class="indent" >  Using (1) the fact that <img 
src="SolvingMicroDSOPs72x.svg" alt="vT =  u(cT)  " class="math";align="absmiddle">; (2) the deﬁnition of <img 
src="SolvingMicroDSOPs73x.svg" alt="u(cT)  " class="math";align="absmiddle">; (3) the deﬁnition of the
expectations operator, this becomes:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs74x.svg" alt="                      1−ρ     ∫
                     cT−1--      ∞ ((mT-−1-−-cT−1)ℛT--+-𝜗)1−ρ-
vT−1(mT − 1) = macTx−1   1 − ρ + β                1 − ρ          d ℱ(𝜗 )
                                0
" class="math-display" ></div>
  </td></tr></table>
                                                                                     
                                                                                     
<!--l. 408--><p class="nopar" >where <img 
src="SolvingMicroDSOPs75x.svg" alt="ℱ " class="math";align="absmiddle"> is the cumulative distribution function for <img 
src="SolvingMicroDSOPs76x.svg" alt="𝜃T  " class="math";align="absmiddle">.
<!--l. 411--><p class="indent" >  The maximization implicitly deﬁnes a function <img 
src="SolvingMicroDSOPs77x.svg" alt="cT− 1(mT  −1)  " class="math";align="absmiddle"> that yields optimal
consumption in period <img 
src="SolvingMicroDSOPs78x.svg" alt="T − 1  " class="math";align="absmiddle"> for any speciﬁc numerical level of resources like <img 
src="SolvingMicroDSOPs79x.svg" alt="mT  −1 = 1.7  " class="math";align="absmiddle">.
But because there is no general analytical solution to this problem, for any given <img 
src="SolvingMicroDSOPs80x.svg" alt="m
  T−1   " class="math";align="absmiddle"> we
must use numerical computational tools to ﬁnd the <img 
src="SolvingMicroDSOPs81x.svg" alt="cT−1   " class="math";align="absmiddle"> that maximizes the expression. This
is excruciatingly slow because for every potential <img 
src="SolvingMicroDSOPs82x.svg" alt="cT−1   " class="math";align="absmiddle"> to be considered, a deﬁnite integral
over the interval <img 
src="SolvingMicroDSOPs83x.svg" alt="(0,∞ )  " class="math";align="absmiddle"> must be calculated numerically, and numerical integration is <span 
class="ecti-1200">very</span>
slow (especially over an unbounded domain!).
<!--l. 413--><p class="indent" >  <a 
 id="Discretizing-the-Distribution"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.1  </span> <a 
 id="x1-80005.1"></a>Discretizing the Distribution</h4>
<!--l. 415--><p class="noindent" >Our ﬁrst speedup trick is therefore to construct a discrete approximation to the
lognormal distribution that can be used in place of numerical integration. That is, we
want to approximate the expectation over <img 
src="SolvingMicroDSOPs84x.svg" alt="𝜃  " class="math";align="absmiddle"> of a function <img 
src="SolvingMicroDSOPs85x.svg" alt="g(𝜃)  " class="math";align="absmiddle"> by calculating its
value at set of <img 
src="SolvingMicroDSOPs86x.svg" alt="n
 𝜃  " class="math";align="absmiddle"> points <img 
src="SolvingMicroDSOPs87x.svg" alt="𝜃
 i  " class="math";align="absmiddle">, each of which has an associated probability weight
<img 
src="SolvingMicroDSOPs88x.svg" alt="wi  " class="math";align="absmiddle">:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs89x.svg" alt="             -
          ∫  𝜃
𝔼 [g(𝜃)] =   (𝜗 )dℱ (𝜗 )
            𝜃
          ∑n
        ≈     wig(𝜃i)
           𝜃=1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 419--><p class="nopar" >(because adding <img 
src="SolvingMicroDSOPs90x.svg" alt="n  " class="math";align="absmiddle"> weighted values to each other is enormously faster than general-purpose
numerical integration).
<!--l. 422--><p class="indent" >  Such a procedure is called a ‘quadrature’ method of integration; <span 
class="ecbx-1200">? </span>survey a number of
options, but for our purposes we choose the one which is easiest to understand: An
‘equiprobable’ approximation (that is, one where each of the values of <img 
src="SolvingMicroDSOPs91x.svg" alt="𝜃i  " class="math";align="absmiddle"> has an equal
probability, equal to <img 
src="SolvingMicroDSOPs92x.svg" alt="1∕n𝜃  " class="math";align="absmiddle">).
<!--l. 424--><p class="indent" >  We calculate such an <img 
src="SolvingMicroDSOPs93x.svg" alt="n  " class="math";align="absmiddle">-point approximation as follows.
<!--l. 426--><p class="indent" >  Deﬁne a set of points from <img 
src="SolvingMicroDSOPs94x.svg" alt="♯0   " class="math";align="absmiddle"> to <img 
src="SolvingMicroDSOPs95x.svg" alt="♯n𝜃   " class="math";align="absmiddle"> on the <img 
src="SolvingMicroDSOPs96x.svg" alt="[0,1]  " class="math";align="absmiddle"> interval as the elements of the set
                                                                                     
                                                                                     
<img 
src="SolvingMicroDSOPs97x.svg" alt="♯ = {0,1 ∕n,2∕n, ...,1} " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs6.html#fn5x0"><sup class="textsuperscript">5</sup></a></span><a 
 id="x1-8001f5"></a>  
Call the inverse of the <img 
src="SolvingMicroDSOPs99x.svg" alt="𝜃  " class="math";align="absmiddle"> distribution <img 
src="SolvingMicroDSOPs100x.svg" alt="  −1
ℱ   " class="math";align="absmiddle">, and deﬁne the points <img 
src="SolvingMicroDSOPs101x.svg" alt=" −1     −1
♯i  = ℱ   (♯i)  " class="math";align="absmiddle">. Then the
conditional mean of <img 
src="SolvingMicroDSOPs102x.svg" alt="𝜃  " class="math";align="absmiddle"> in each of the intervals numbered 1 to <img 
src="SolvingMicroDSOPs103x.svg" alt="n  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs104x.svg" alt="                          ∫  ♯−1
𝜃  ≡ 𝔼[𝜃|♯−1 ≤ 𝜃 &#x003C;  ♯− 1] =   i  𝜗 dℱ (𝜗),
 i        i− 1       i       ♯−1
                            i−1
" class="math-display" ><a 
 id="x1-8003r21"></a></div>
  </td><td class="equation-label">(21)</td></tr></table>
<!--l. 432--><p class="nopar" >and when the integral is evaluated numerically for each <img 
src="SolvingMicroDSOPs105x.svg" alt="i  " class="math";align="absmiddle"> the result is a set of values of <img 
src="SolvingMicroDSOPs106x.svg" alt="𝜃  " class="math";align="absmiddle">
that correspond to the mean value in each of the <img 
src="SolvingMicroDSOPs107x.svg" alt="n  " class="math";align="absmiddle"> intervals.
<!--l. 435--><p class="indent" >  The method is illustrated in Figure <a 
href="#x1-80061">1<!--tex4ht:ref: fig:discreteapprox --></a>. The solid continuous curve represents the “true” CDF
<img 
src="SolvingMicroDSOPs108x.svg" alt="ℱ (𝜃)  " class="math";align="absmiddle"> for a lognormal distribution such that <img 
src="SolvingMicroDSOPs109x.svg" alt="𝔼 [𝜃 ] = 1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs110x.svg" alt="σ𝜃 = 0.1  " class="math";align="absmiddle">. The short vertical line
segments represent the <img 
src="SolvingMicroDSOPs111x.svg" alt="n 𝜃  " class="math";align="absmiddle"> equiprobable values of <img 
src="SolvingMicroDSOPs112x.svg" alt="𝜃i  " class="math";align="absmiddle"> which are used to approximate this
distribution.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs7.html#fn6x0"><sup class="textsuperscript">6</sup></a></span><a 
 id="x1-8004f6"></a>   <a 
 id="discreteApprox"></a>
<div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-80061"></a>
                                                                                     
                                                                                     
<!--l. 3--><p class="noindent" > <img 
src="./Figures/discreteApprox.png" alt="pict"  
 width="358.50612pt" >
<figcaption class="caption" ><span class="id">Figure 1: </span><span  
class="content">Equiprobable Discrete Approximation to Lognormal Distribution <img 
src="SolvingMicroDSOPs113x.svg" alt="ℱ " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-80061 -->          <span 
class="ecrm-0600">{ﬁg:discreteapprox}</span>
                                                                                     
                                                                                     
  </div>
  <!--l. 456--><pre class="lstinputlisting" id="listing-1"><span class="label"><a 
 id="x1-8008r1"></a></span><span style="color:#000000"><span 
class="ecit-1000">#</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">This</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">is</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">a</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">snippet</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">of</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">code</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">that</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">constructs</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">mass</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">points</span></span> 
<span class="label"><a 
 id="x1-8009r2"></a></span><span style="color:#000000"><span 
class="ecit-1000">#</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">for</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">the</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">equiprobable</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">representation</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">of</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">the</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">problem</span></span>
  </pre>
<!--l. 458--><p class="indent" >  Because one of the purposes of these notes is to connect the math to the code that solves
the math, we display here a brief snippet from the notebook that constructs these
points:
<!--l. 460--><p class="indent" >  Substituting into our deﬁnition of <img 
src="SolvingMicroDSOPs114x.svg" alt="vT −1
     → " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs115x.svg" alt="                 (    )  n𝜃             1− ρ
                   -1-  ∑   (ℛT-aT-+-𝜃i)---
vT −1→(aT −1) = β  n 𝜃           1 − ρ
                        i=1
" class="math-display" ><a 
 id="x1-8012r22"></a></div>
  </td><td class="equation-label">(22)</td></tr></table>
<!--l. 3--><p class="nopar" >so we can rewrite the maximization problem that deﬁnes the middle stage of the period <img 
src="SolvingMicroDSOPs116x.svg" alt="  " class="math";align="absmiddle">
as
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs117x.svg" alt="                   {                             }
                     c1−ρ
vT−1(mT −1) = max    -T−1-+  v←T −1(mT −1 − cT−1)  .
              cT−1   1 − ρ
" class="math-display" ><a 
 id="x1-8013r23"></a></div>
  </td><td class="equation-label">(23)</td></tr></table>
<!--l. 9--><p class="nopar" >
  <!--l. 481--><pre class="lstinputlisting" id="listing-2"><span class="label"><a 
 id="x1-8015r1"></a></span><span style="color:#000000"><span 
class="ecit-1000">#</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">The</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">code</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">that</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">corresponds</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">to</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">evaluation</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">of</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">the</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">discretized</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">max</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">problem</span></span><span style="color:#000000"> </span><span style="color:#000000"><span 
class="ecit-1000">is</span></span>
  </pre>
<!--l. 490--><p class="indent" >  <a 
 id="The-Approximate-Consumption-and-Value-Functions"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.2  </span> <a 
 id="x1-90005.2"></a>The Approximate Consumption and Value Functions</h4>
<!--l. 493--><p class="noindent" >Given a particular value of <img 
src="SolvingMicroDSOPs118x.svg" alt="m
  T−1   " class="math";align="absmiddle">, a numerical maximization routine can now ﬁnd the <img 
src="SolvingMicroDSOPs119x.svg" alt="c
 T−1   " class="math";align="absmiddle">
that maximizes (<a 
href="#x1-8013r23">23<!--tex4ht:ref: eq:vEndTm1 --></a>) in a reasonable amount of time.
<!--l. 505--><p class="indent" >  The heart of the program responsible for computing an estimated consumption
function begins in “Solving the Model by Value Function Maximization,” where a grid
characterizing the possible values of market resources (<img 
src="SolvingMicroDSOPs120x.svg" alt="m  " class="math";align="absmiddle">) is initialized (in the code, various
<img 
src="SolvingMicroDSOPs121x.svg" alt="m  " class="math";align="absmiddle"> vectors have names beginning ), and for each of the  values, the consumption
values <img 
src="SolvingMicroDSOPs122x.svg" alt="c  " class="math";align="absmiddle"> that solve the minimization problem equivalent to (<a 
href="#x1-8013r23">23<!--tex4ht:ref: eq:vEndTm1 --></a>) are computed. We
arbitrarily pick the ﬁrst ﬁve integers as our ﬁve  gridpoints. (That is, <span 
class="ectt-1200">mVec_int</span>=
<img 
src="SolvingMicroDSOPs123x.svg" alt="{0.,1.,2.,3.,4.} " class="math";align="absmiddle">.
<!--l. 512--><p class="indent" >  <a 
 id="an-interpolated-consumption-function"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.3  </span> <a 
 id="x1-100005.3"></a>An Interpolated Consumption Function</h4>                                          <span 
class="ecrm-0600">{subsec:LinInterp}</span>
<!--l. 515--><p class="noindent" >Given a set of points on a function (in this case, the consumption function <img 
src="SolvingMicroDSOPs124x.svg" alt="cT−1(m )  " class="math";align="absmiddle">), we can
create a piecewise linear ‘interpolating function’ (a ‘spline’) which when applied to an input
<img 
src="SolvingMicroDSOPs125x.svg" alt="m  " class="math";align="absmiddle"> will yield the value of <img 
src="SolvingMicroDSOPs126x.svg" alt="c  " class="math";align="absmiddle"> that corresponds to a linear ‘connect-the-dots’ interpolation of
the value of <img 
src="SolvingMicroDSOPs127x.svg" alt="c  " class="math";align="absmiddle"> from the points, creating a function that is an approximation of the function
whose points have been sampled.
<!--l. 517--><p class="indent" >  This is accompished in “An Interpolated Consumption Function,” which deﬁnes an
approximation to the consumption function <img 
src="SolvingMicroDSOPs128x.svg" alt="`cT(mT −1)  " class="math";align="absmiddle">. That is, when called with an <img 
src="SolvingMicroDSOPs129x.svg" alt="mT − 1   " class="math";align="absmiddle">
that is equal to one of the points in _int, <img 
src="SolvingMicroDSOPs130x.svg" alt="`cT− 1   " class="math";align="absmiddle"> returns the associated value of
<img 
src="SolvingMicroDSOPs131x.svg" alt="cccT−1 " class="math";align="absmiddle">, and when called with a value of <img 
src="SolvingMicroDSOPs132x.svg" alt="mT −1   " class="math";align="absmiddle"> that is not exactly equal to one of the
<span 
class="ectt-1200">mVec_int</span>, returns the value of <img 
src="SolvingMicroDSOPs133x.svg" alt="c  " class="math";align="absmiddle"> that reﬂects a linear interpolation between the
<img 
src="SolvingMicroDSOPs134x.svg" alt="cccT−1 " class="math";align="absmiddle"> points associated with the two <span 
class="ectt-1200">mVec_int </span>points immediately above and below
<img 
src="SolvingMicroDSOPs135x.svg" alt="mT − 1   " class="math";align="absmiddle">.
<!--l. 523--><p class="indent" >  Figures <a 
href="#x1-100032">2<!--tex4ht:ref: fig:PlotcTm1Simple --></a> and <a 
href="#x1-100043">3<!--tex4ht:ref: fig:PlotVTm1Simple --></a> show plots of the constructed <img 
src="SolvingMicroDSOPs136x.svg" alt="`cT−1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs137x.svg" alt="`vT−1   " class="math";align="absmiddle">. While the <img 
src="SolvingMicroDSOPs138x.svg" alt="`cT −1   " class="math";align="absmiddle">
function looks very smooth, the fact that the <img 
src="SolvingMicroDSOPs139x.svg" alt="`vT−1   " class="math";align="absmiddle">  function is a set of line
segments is very evident. This ﬁgure provides the beginning of the intuition for
why trying to approximate the value function directly is a bad idea (in this
context).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs8.html#fn7x0"><sup class="textsuperscript">7</sup></a></span><a 
 id="x1-10001f7"></a>  
<!--l. 526--><p class="indent" >  <a 
 id="PlotcTm1Simple"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100032"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotcTm1Simple.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 2: </span><span  
class="content"><img 
src="SolvingMicroDSOPs140x.svg" alt="cT− 1(mT  −1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs141x.svg" alt="`cT−1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-100032 -->                            <span 
class="ecrm-0600">{ﬁg:PlotcTm1Simple}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 533--><p class="indent" >  <a 
 id="PlotvTm1Simple"></a>  <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-100043"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                          <img 
src="./Figures/PlotVTm1Simple.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 3: </span><span  
class="content"><img 
src="SolvingMicroDSOPs142x.svg" alt="vT −1   " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs143x.svg" alt="`vT−1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-100043 -->                                   <span 
class="ecrm-0600">{ﬁg:PlotVTm1Simple}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 540--><p class="indent" >  <a 
 id="Interpolating-Expectations"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.4  </span> <a 
 id="x1-110005.4"></a>Interpolating Expectations</h4>
<!--l. 546--><p class="noindent" >Picewise linear ‘spline’ interpolation as described above works well for generating a good
approximation to the true optimal consumption function. However, there is a clear ineﬃciency
in the program: Since it uses equation (<a 
href="#x1-8013r23">23<!--tex4ht:ref: eq:vEndTm1 --></a>), for every value of <img 
src="SolvingMicroDSOPs144x.svg" alt="mT − 1   " class="math";align="absmiddle"> the program must
calculate the utility consequences of various possible choices of <img 
src="SolvingMicroDSOPs145x.svg" alt="cT− 1   " class="math";align="absmiddle"> as it searches for the
best choice.
<!--l. 548--><p class="indent" >  For any given value of <img 
src="SolvingMicroDSOPs146x.svg" alt="a
 T−1   " class="math";align="absmiddle">, notice that there is a good chance that the program may end
up calculating the corresponding <img 
src="SolvingMicroDSOPs147x.svg" alt="vT  " class="math";align="absmiddle"> many times while maximizing utility from diﬀerent
<img 
src="SolvingMicroDSOPs148x.svg" alt="mT − 1   " class="math";align="absmiddle">’s. For example, it is possible that the program will calculate the value of ending the
period with <img 
src="SolvingMicroDSOPs149x.svg" alt="aT −1 = 0  " class="math";align="absmiddle"> dozens of times. It would be much more eﬃcient if the program could
make the calculation of <img 
src="SolvingMicroDSOPs150x.svg" alt="vT(0)  " class="math";align="absmiddle"> once and then merely recall the value when it is needed
again.
<!--l. 550--><p class="indent" >  Something like this can be achieved using the same interpolation technique used above to
construct a direct numerical approximation to the value function: Deﬁne a vector of possible
values for end-of-period assets at time <img 
src="SolvingMicroDSOPs151x.svg" alt="T −  1  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs152x.svg" alt="aaaT−1  " class="math";align="absmiddle"> (<span 
class="ectt-1200">aVec </span>in the code). Next, construct
<img 
src="SolvingMicroDSOPs153x.svg" alt="vvvT−1 = vT −1(aaaT−1)  " class="math";align="absmiddle"> using equation (<a 
href="#x1-8013r23">23<!--tex4ht:ref: eq:vEndTm1 --></a>); then construct an approximation <img 
src="SolvingMicroDSOPs154x.svg" alt="`vT− 1 (aT− 1)
     →  " class="math";align="absmiddle"> by
passing the lists <span 
class="ectt-1200">aVec </span>and <span 
class="ectt-1200">vVec </span>as arguments. These lists contain the points of the <img 
src="SolvingMicroDSOPs155x.svg" alt="aaa
  T−1  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs156x.svg" alt="vvvT− 1 " class="math";align="absmiddle"> vectors, respectively.
<!--l. 563--><p class="indent" >  As seen in the section “Interpolating Expectations,” we are now interpolating for the
function that reveals the expected value of <span 
class="ecti-1200">ending </span>the period with a given amount of
assets.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs9.html#fn8x0"><sup class="textsuperscript">8</sup></a></span><a 
 id="x1-11001f8"></a>  
<!--l. 570--><p class="indent" >  Figure <a 
href="#x1-110034">4<!--tex4ht:ref: fig:PlotOTm1RawVSInt --></a> compares the true value function to the approximation produced following the
interpolation procedure; the functions are of course identical at the gridpoints of <img 
src="SolvingMicroDSOPs157x.svg" alt="aT−1   " class="math";align="absmiddle"> and
they appear reasonably close except in the region below <img 
src="SolvingMicroDSOPs158x.svg" alt="mT −1 = 1  " class="math";align="absmiddle">.
<!--l. 577--><p class="indent" >  <a 
 id="PlotOTm1RawVSInt"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-110034"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotOTm1RawVSInt.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 4: </span><span  
class="content">End-Of-Period Value <img 
src="SolvingMicroDSOPs159x.svg" alt="vT −1 (aT −1)
     →  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs160x.svg" alt="`vT−1  (aT−1)
    →  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-110034 -->     <span 
class="ecrm-0600">{ﬁg:PlotOTm1RawVSInt}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 584--><p class="indent" >  <a 
 id="PlotComparecTm1AB"></a>  <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-110045"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                          <img 
src="./Figures/PlotComparecTm1AB.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 5: </span><span  
class="content"><img 
src="SolvingMicroDSOPs161x.svg" alt="cT− 1(mT  −1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs162x.svg" alt="`cT−1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-110045 -->                            <span 
class="ecrm-0600">{ﬁg:PlotComparecTm1AB}</span>
                                                                                     
                                                                                     
  </div>
  <div class="marginpar">
<!--l. 592--><p class="indent" >  <span 
class="ecrm-0600">In all ﬁgs, replace gothic h with notation corresponding to the lecture notes.</span></div>Nevertheless, the consumption rule obtained
when the approximating <img 
src="SolvingMicroDSOPs163x.svg" alt="`v     (a   )
 T−1→   T−1  " class="math";align="absmiddle"> is used instead of <img 
src="SolvingMicroDSOPs164x.svg" alt="v     (a   )
 T−1→   T−1  " class="math";align="absmiddle"> is surprisingly bad, as
shown in ﬁgure <a 
href="#x1-110045">5<!--tex4ht:ref: fig:PlotComparecTm1AB --></a>. For example, when <img 
src="SolvingMicroDSOPs165x.svg" alt="mT  −1   " class="math";align="absmiddle"> goes from 2 to 3, <img 
src="SolvingMicroDSOPs166x.svg" alt="`cT− 1   " class="math";align="absmiddle"> goes from about 1 to
about 2, yet when <img 
src="SolvingMicroDSOPs167x.svg" alt="mT −1   " class="math";align="absmiddle"> goes from 3 to 4, <img 
src="SolvingMicroDSOPs168x.svg" alt="c`T −1   " class="math";align="absmiddle"> goes from about 2 to about 2.05. The
function fails even to be strictly concave, which is distressing because Carroll and Kimball (<span 
class="ecbx-1200">?</span>)
prove that the correct consumption function is strictly concave in a wide class of problems
that includes this problem.
<!--l. 606--><p class="indent" >  <a 
 id="Value-Function-versus-First-Order-Condition"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.5  </span> <a 
 id="x1-120005.5"></a>Value Function versus First Order Condition</h4>                                     <span 
class="ecrm-0600">{subsec:vVsuP}</span>
<!--l. 609--><p class="noindent" >Loosely speaking, our diﬃculty reﬂects the fact that the consumption choice is governed by
the <span 
class="ecti-1200">marginal </span>value function, not by the <span 
class="ecti-1200">level </span>of the value function (which is the object that we
approximated). To understand this point, recall that a quadratic utility function exhibits risk
aversion because with a stochastic <img 
src="SolvingMicroDSOPs169x.svg" alt="c  " class="math";align="absmiddle">,
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs170x.svg" alt="𝔼 [− (c − c)2] &#x003C; − (𝔼[c] − c)2
         /              /
" class="math-display" ><a 
 id="x1-12001r24"></a></div>
  </td><td class="equation-label">(24)</td></tr></table>
<!--l. 621--><p class="nopar" >(where <img 
src="SolvingMicroDSOPs171x.svg" alt="/c  " class="math";align="absmiddle"> is the ‘bliss point’ which is assumed always to exceed feasible <img 
src="SolvingMicroDSOPs172x.svg" alt="c  " class="math";align="absmiddle">). However, unlike
the CRRA utility function, with quadratic utility the consumption/saving <span 
class="ecti-1200">behavior </span>of
consumers is unaﬀected by risk since behavior is determined by the ﬁrst order condition,
which depends on <span 
class="ecti-1200">marginal </span>utility, and when utility is quadratic, marginal utility is unaﬀected
by risk:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs173x.svg" alt="𝔼[− 2(c − /c)] = − 2(𝔼[c] − /c).
" class="math-display" ><a 
 id="x1-12002r25"></a></div>
  </td><td class="equation-label">(25)</td></tr></table>
<!--l. 629--><p class="nopar" >
<!--l. 631--><p class="indent" >  Intuitively, if one’s goal is to accurately capture choices that are governed by marginal
value, numerical techniques that approximate the <span 
class="ecti-1200">marginal </span>value function will yield a more
accurate approximation to optimal behavior than techniques that approximate the <span 
class="ecti-1200">level </span>of the
value function.
<!--l. 638--><p class="indent" >  The ﬁrst order condition of the maximization problem in period <img 
src="SolvingMicroDSOPs174x.svg" alt="T − 1  " class="math";align="absmiddle"> is:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs175x.svg" alt=" c                      c
u (cT−1) = β 𝔼→ (T−1)[Ru  (cT )]
              (  1 ) n∑𝜃
    c−Tρ−1 = Rβ   ---     (R (mT  −1 − cT−1) + 𝜃i)−ρ .
                n𝜃   i=1
" class="math-display" ><a 
 id="x1-12003r26"></a></div>
  </td><td class="equation-label">(26)</td></tr></table>
<!--l. 4--><p class="nopar" > <a 
 id="PlotuPrimeVSOPrime"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120046"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotuPrimeVSOPrime.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 6: </span><span  
class="content"><img 
src="SolvingMicroDSOPs176x.svg" alt="uc(c)  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs177x.svg" alt="va    (3 − c),va    (4 − c),`va    (3 − c),`va    (4 − c)
 T− 1→          T−1→         T −1→         T−1→  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120046 -->         <span 
class="ecrm-0600">{ﬁg:PlotuPrimeVSOPrime}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 654--><p class="indent" >  In the notebook, the “Value Function versus the First Order Condition” section completes
the task of ﬁnding the values of consumption which satisfy the ﬁrst order condition in (<a 
href="#x1-12003r26">26<!--tex4ht:ref: eq:FOCTm1 --></a>)
using the  <a 
href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.brentq.html" >brentq</a> function from the <span 
class="ectt-1200">scipy </span>package.
<!--l. 656--><p class="indent" >  The downward-sloping curve in Figure <a 
href="#x1-120046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> shows the value of <img 
src="SolvingMicroDSOPs178x.svg" alt=" −ρ
cT−1   " class="math";align="absmiddle"> for our baseline
parameter values for <img 
src="SolvingMicroDSOPs179x.svg" alt="0 ≤ cT− 1 ≤ 4  " class="math";align="absmiddle"> (the horizontal axis). The solid upward-sloping curve
shows the value of the RHS of (<a 
href="#x1-12003r26">26<!--tex4ht:ref: eq:FOCTm1 --></a>) as a function of <img 
src="SolvingMicroDSOPs180x.svg" alt="cT −1   " class="math";align="absmiddle"> under the assumption that
<img 
src="SolvingMicroDSOPs181x.svg" alt="mT − 1 = 3  " class="math";align="absmiddle">. Constructing this ﬁgure is time-consuming, because for every value of <img 
src="SolvingMicroDSOPs182x.svg" alt="cT −1   " class="math";align="absmiddle">
plotted we must calculate the RHS of (<a 
href="#x1-12003r26">26<!--tex4ht:ref: eq:FOCTm1 --></a>). The value of <img 
src="SolvingMicroDSOPs183x.svg" alt="cT−1   " class="math";align="absmiddle"> for which the RHS and LHS of
(<a 
href="#x1-12003r26">26<!--tex4ht:ref: eq:FOCTm1 --></a>) are equal is the optimal level of consumption given that <img 
src="SolvingMicroDSOPs184x.svg" alt="mT −1 = 3  " class="math";align="absmiddle">, so the intersection of
the downward-sloping and the upward-sloping curves gives the (approximated) optimal value
of <img 
src="SolvingMicroDSOPs185x.svg" alt="cT−1   " class="math";align="absmiddle">. As we can see, the two curves intersect just below <img 
src="SolvingMicroDSOPs186x.svg" alt="cT−1 = 2  " class="math";align="absmiddle">. Similarly, the
upward-sloping dashed curve shows the expected value of the RHS of (<a 
href="#x1-12003r26">26<!--tex4ht:ref: eq:FOCTm1 --></a>) under the
assumption that <img 
src="SolvingMicroDSOPs187x.svg" alt="mT −1 = 4  " class="math";align="absmiddle">, and the intersection of this curve with <img 
src="SolvingMicroDSOPs188x.svg" alt="  c
u (cT− 1)  " class="math";align="absmiddle"> yields the
optimal level of consumption if <img 
src="SolvingMicroDSOPs189x.svg" alt="mT  −1 = 4  " class="math";align="absmiddle">. These two curves intersect slightly below
<img 
src="SolvingMicroDSOPs190x.svg" alt="cT− 1 = 2.5  " class="math";align="absmiddle">. Thus, increasing <img 
src="SolvingMicroDSOPs191x.svg" alt="mT −1   " class="math";align="absmiddle"> from 3 to 4 increases optimal consumption by about
0.5.
<!--l. 677--><p class="indent" >  Now consider the derivative of our function <img 
src="SolvingMicroDSOPs192x.svg" alt="`v     (a    )
 T−1→   T−1  " class="math";align="absmiddle">. Because we have constructed
<img 
src="SolvingMicroDSOPs193x.svg" alt="`vT −1→ " class="math";align="absmiddle"> as a linear interpolation, the slope of <img 
src="SolvingMicroDSOPs194x.svg" alt="`vT− 1→ (aT− 1)  " class="math";align="absmiddle"> between any two adjacent points
<img 
src="SolvingMicroDSOPs195x.svg" alt="{aaa [i],,aaa[i + 1]} " class="math";align="absmiddle"> is constant. The level of the slope immediately below any particular gridpoint
is diﬀerent, of course, from the slope above that gridpoint, a fact which implies that the
derivative of <img 
src="SolvingMicroDSOPs196x.svg" alt="`vT− 1→ (aT− 1)  " class="math";align="absmiddle"> follows a step function.
<!--l. 687--><p class="indent" >  The solid-line step function in Figure <a 
href="#x1-120046">6<!--tex4ht:ref: fig:PlotuPrimeVSOPrime --></a> depicts the actual value of <img 
src="SolvingMicroDSOPs197x.svg" alt="`va    (3 − c    )
 T−1→      T −1  " class="math";align="absmiddle">. When
we attempt to ﬁnd optimal values of <img 
src="SolvingMicroDSOPs198x.svg" alt="cT−1   " class="math";align="absmiddle"> given <img 
src="SolvingMicroDSOPs199x.svg" alt="mT −1   " class="math";align="absmiddle"> using <img 
src="SolvingMicroDSOPs200x.svg" alt="`vT −1→(aT− 1)  " class="math";align="absmiddle">, the numerical
optimization routine will return the <img 
src="SolvingMicroDSOPs201x.svg" alt="cT−1   " class="math";align="absmiddle"> for which <img 
src="SolvingMicroDSOPs202x.svg" alt=" c          a
u (cT−1) = `vT− 1→(mT −1 − cT−1)  " class="math";align="absmiddle">. Thus,
for <img 
src="SolvingMicroDSOPs203x.svg" alt="mT −1 = 3  " class="math";align="absmiddle"> the program will return the value of <img 
src="SolvingMicroDSOPs204x.svg" alt="cT− 1   " class="math";align="absmiddle"> for which the downward-sloping
<img 
src="SolvingMicroDSOPs205x.svg" alt="uc(cT− 1)  " class="math";align="absmiddle"> curve intersects with the <img 
src="SolvingMicroDSOPs206x.svg" alt="`va    (3 − cT−1)
 T −1→  " class="math";align="absmiddle">; as the diagram shows, this value is
exactly equal to 2. Similarly, if we ask the routine to ﬁnd the optimal <img 
src="SolvingMicroDSOPs207x.svg" alt="c
 T−1   " class="math";align="absmiddle"> for <img 
src="SolvingMicroDSOPs208x.svg" alt="m     =  4
  T −1  " class="math";align="absmiddle">, it
ﬁnds the point of intersection of <img 
src="SolvingMicroDSOPs209x.svg" alt=" c
u (cT−1)  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs210x.svg" alt=" a
`vT−1→ (4 − cT− 1)  " class="math";align="absmiddle">; and as the diagram shows,
this intersection is only slightly above 2. Hence, this ﬁgure illustrates why the numerical
consumption function plotted earlier returned values very close to <img 
src="SolvingMicroDSOPs211x.svg" alt="cT−1 = 2  " class="math";align="absmiddle"> for both
<img 
src="SolvingMicroDSOPs212x.svg" alt="mT − 1 = 3  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs213x.svg" alt="mT − 1 = 4  " class="math";align="absmiddle">.
<!--l. 706--><p class="indent" >  We would obviously obtain much better estimates of the point of intersection between
<img 
src="SolvingMicroDSOPs214x.svg" alt=" c
u (cT− 1)  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs215x.svg" alt=" a
vT−1→ (mT −1 − cT−1)  " class="math";align="absmiddle"> if our estimate of <img 
src="SolvingMicroDSOPs216x.svg" alt=" a
`vT−1→ " class="math";align="absmiddle"> were not a step function. In
fact, we already know how to construct linear interpolations to functions, so the obvious next
step is to construct a linear interpolating approximation to the <span 
class="ecti-1200">expected marginal value of</span>
<span 
class="ecti-1200">end-of-period assets function</span> <img 
src="SolvingMicroDSOPs217x.svg" alt="va
 T− 1→ " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs218x.svg" alt="                   (   )  n𝜃
 a                   1-- ∑                 −ρ
vT −1→(aT− 1) = βR   n𝜃      (ℛT aT− 1 + 𝜃i)
                          i=1
" class="math-display" ><a 
 id="x1-12005r27"></a></div>
  </td><td class="equation-label">(27)</td></tr></table>
<!--l. 716--><p class="nopar" >at the points in <span 
class="ectt-1200">aVec </span>yielding <img 
src="SolvingMicroDSOPs219x.svg" alt="vvva
 T−1→ " class="math";align="absmiddle"> (the vector of expected end-of-period-<img 
src="SolvingMicroDSOPs220x.svg" alt="(T −  1)  " class="math";align="absmiddle"> marginal
values of assets corresponding to <span 
class="ectt-1200">aVec</span>), and construct <img 
src="SolvingMicroDSOPs221x.svg" alt="  a
`v T−1→(aT −1)  " class="math";align="absmiddle"> as the linear
interpolating function that ﬁts this set of points.
<!--l. 722--><p class="indent" >  <a 
 id="PlotOPRawVSFOC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120067"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotOPRawVSFOC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 7: </span><span  
class="content"><img 
src="SolvingMicroDSOPs222x.svg" alt="va    (aT− 1)
 T −1→  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs223x.svg" alt="`va    (aT −1)
  T−1→  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120067 -->                                           <span 
class="ecrm-0600">{ﬁg:PlotOPRawVSFOC}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 732--><p class="indent" >  The results are shown in Figure <a 
href="#x1-120067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>. The linear interpolating approximation looks roughly as
good (or bad) for the <span 
class="ecti-1200">marginal </span>value function as it was for the level of the value function.
However, Figure <a 
href="#x1-120078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a> shows that the new consumption function (long dashes) is a
considerably better approximation of the true consumption function (solid) than was the
consumption function obtained by approximating the level of the value function (short
dashes).
<!--l. 742--><p class="indent" >  <a 
 id="PlotcTm1ABC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-120078"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotcTm1ABC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 8: </span><span  
class="content"><img 
src="SolvingMicroDSOPs224x.svg" alt="cT− 1(mT  −1)  " class="math";align="absmiddle"> (solid) Versus Two Methods for Constructing <img 
src="SolvingMicroDSOPs225x.svg" alt="`cT−1(mT −1)  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-120078 -->      <span 
class="ecrm-0600">{ﬁg:PlotcTm1ABC}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 749--><p class="indent" >  <a 
 id="Transformation"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.6  </span> <a 
 id="x1-130005.6"></a>Transformation</h4>                                                                  <span 
class="ecrm-0600">{subsec:transformation}</span>
<!--l. 752--><p class="noindent" >Even the new-and-improved consumption function diverges notably from the true solution,
especially at lower values of <img 
src="SolvingMicroDSOPs226x.svg" alt="m  " class="math";align="absmiddle">. That is because the linear interpolation does an increasingly
poor job of capturing the nonlinearity of <img 
src="SolvingMicroDSOPs227x.svg" alt=" a
vT− 1→ (aT−1)  " class="math";align="absmiddle"> at lower and lower levels of
<img 
src="SolvingMicroDSOPs228x.svg" alt="a  " class="math";align="absmiddle">.
<!--l. 758--><p class="indent" >  This is where we unveil our next trick. To understand the logic, start by considering the
case where <img 
src="SolvingMicroDSOPs229x.svg" alt="ℛ   =  β = 𝒢  =  1
  T         T  " class="math";align="absmiddle"> and there is no uncertainty  (that is, we know for sure that
income next period will be <img 
src="SolvingMicroDSOPs230x.svg" alt="𝜃T = 1  " class="math";align="absmiddle">). The ﬁnal Euler equation is then:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs231x.svg" alt="c−ρ  = c− ρ.
 T−1    T
" class="math-display" ><a 
 id="x1-13001r28"></a></div>
  </td><td class="equation-label">(28)</td></tr></table>
<!--l. 766--><p class="nopar" >
<!--l. 768--><p class="indent" >  In the case we are now considering with no uncertainty and no liquidity constraints, the
optimizing consumer does not care whether a unit of income is scheduled to be received in the
future period <img 
src="SolvingMicroDSOPs232x.svg" alt="T  " class="math";align="absmiddle"> or the current period <img 
src="SolvingMicroDSOPs233x.svg" alt="T − 1  " class="math";align="absmiddle">; there is perfect certainty that the income will
be received, so the consumer treats its PDV as equivalent to a unit of current wealth.
Total resources available at the point when the consumption decision is made is
therefore are comprised of two types: current market resources <img 
src="SolvingMicroDSOPs234x.svg" alt="mT −1   " class="math";align="absmiddle"> and ‘human
wealth’ (the PDV of future income) of <img 
src="SolvingMicroDSOPs235x.svg" alt="hT−1→ =  1  " class="math";align="absmiddle"> (because it is the value of human
wealth as of the end of the period, and there is only one more period of income of 1
left).
<!--l. 778--><p class="indent" >  The optimal solution is to spend half of total lifetime resources in period <img 
src="SolvingMicroDSOPs236x.svg" alt="T − 1  " class="math";align="absmiddle">
and the remainder in period <img 
src="SolvingMicroDSOPs237x.svg" alt="T  " class="math";align="absmiddle">. Since total resources are known with certainty
to be <img 
src="SolvingMicroDSOPs238x.svg" alt="mT − 1 + hT −1 = mT −1 + 1  " class="math";align="absmiddle">, and since <img 
src="SolvingMicroDSOPs239x.svg" alt=" m            c
vT (mT  −1) = u (cT−1)  " class="math";align="absmiddle"> this implies
that
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs240x.svg" alt="               ( m    +  1) −ρ
vmT −1(mT −1) =   --T−1-----   .
                     2
" class="math-display" ><a 
 id="x1-13002r29"></a></div>
  </td><td class="equation-label">(29)</td></tr></table>
<!--l. 789--><p class="nopar" >Of course, this is a highly nonlinear function. However, if we raise both sides of (<a 
href="#x1-13002r29">29<!--tex4ht:ref: eq:vPLin --></a>) to the
power <img 
src="SolvingMicroDSOPs241x.svg" alt="(− 1 ∕ρ)  " class="math";align="absmiddle"> the result is a linear function:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs242x.svg" alt="                    mT −1 + 1
[vmT −1(mT −1)]− 1∕ρ =  ---------.
                        2
" class="math-display" ><a 
 id="x1-13003r30"></a></div>
  </td><td class="equation-label">(30)</td></tr></table>
<!--l. 795--><p class="nopar" >This is a speciﬁc example of a general phenomenon: A theoretical literature discussed in <span 
class="ecbx-1200">?</span>
establishes that under perfect certainty, if the period-by-period marginal utility function is of
the form <img 
src="SolvingMicroDSOPs243x.svg" alt="c−t ρ  " class="math";align="absmiddle">, the marginal value function will be of the form <img 
src="SolvingMicroDSOPs244x.svg" alt="(γmt + ζ)− ρ  " class="math";align="absmiddle"> for
some constants <img 
src="SolvingMicroDSOPs245x.svg" alt="{γ,ζ} " class="math";align="absmiddle">. This means that if we were solving the perfect foresight
problem numerically, we could always calculate a numerically exact (because linear)
interpolation.
<!--l. 805--><p class="indent" >  To put the key insight in intuitive terms, the problem we are facing springs in large part
from the fact that the marginal value function is highly nonlinear. But we have a compelling
solution to that problem, because the nonlinearity springs largely from the fact that we are
raising something to the power <img 
src="SolvingMicroDSOPs246x.svg" alt="− ρ  " class="math";align="absmiddle">. In eﬀect, we can ‘unwind’ all of the nonlinearity owing
to that operation and the remaining nonlinearity will not be nearly so great. Speciﬁcally,
applying the foregoing insights to the end-of-period value function <img 
src="SolvingMicroDSOPs247x.svg" alt="vaT−1(aT −1)  " class="math";align="absmiddle">, we can
deﬁne
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs248x.svg" alt="               ( a          )− 1∕ρ
cT−1→ (aT−1) ≡  vT− 1→(aT− 1)
" class="math-display" ><a 
 id="x1-13004r31"></a></div>
  </td><td class="equation-label">(31)</td></tr></table>
<!--l. 815--><p class="nopar" >which would be linear in the perfect foresight case. Thus, our procedure is to calculate the
values of <img 
src="SolvingMicroDSOPs249x.svg" alt="cT −1   " class="math";align="absmiddle"> at each of the <img 
src="SolvingMicroDSOPs250x.svg" alt="aaaT−1  " class="math";align="absmiddle"> gridpoints, with the idea that we will construct <img 
src="SolvingMicroDSOPs251x.svg" alt="`cT− 1→ " class="math";align="absmiddle">
as the interpolating function connecting these points.
<!--l. 824--><p class="indent" >  Note that this is <span 
class="ecti-1200">not </span>a consumption function. It is a ‘consumed’ function - it reveals the
amount that must have been consumed for the consumer to have arrived at the end of the
period with a given amount of assets.
<!--l. 827--><p class="indent" >  <a 
 id="The-Natural-Borrowing-Constraint-and-the-a-Lower-Bound"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.7  </span> <a 
 id="x1-140005.7"></a>The Natural Borrowing Constraint and the <img 
src="SolvingMicroDSOPs252x.svg" alt="aT −1   " class="math";align="absmiddle"> Lower Bound</h4>                  <span 
class="ecrm-0600">{subsec:LiqConstrSelfImposed}</span>
<!--l. 831--><p class="noindent" >This is the appropriate moment to ask an awkward question we have so far neglected: How
should a function like <img 
src="SolvingMicroDSOPs253x.svg" alt="`cT− 1→ " class="math";align="absmiddle"> be evaluated outside the range of points spanned by
<img 
src="SolvingMicroDSOPs254x.svg" alt="{a    [1],...,a   [n]}
   T− 1       T−1 " class="math";align="absmiddle"> for which we have calculated the corresponding <img 
src="SolvingMicroDSOPs255x.svg" alt="c
 T−1→ " class="math";align="absmiddle"> values used to
produce our linearly interpolating approximation <img 
src="SolvingMicroDSOPs256x.svg" alt="`cT−1→ " class="math";align="absmiddle">?
<!--l. 838--><p class="indent" >  For most piecewise-linear interpolation implementations, when the interplating function is
evaluated at a point outside the provided range of values used to construct the function, the
algorithm silently performs extrapolation under the assumption that the slope of the function
remains the same beyond the measured boundaries as within the nearest piecewise segment to
the point.
<!--l. 845--><p class="indent" >  The easiest answer would be linear extrapolation; for example, if the bottommost gridpoint
is <img 
src="SolvingMicroDSOPs257x.svg" alt="a1 = aaaT−1[1 ]  " class="math";align="absmiddle"> and the corresponding level of consumption is <img 
src="SolvingMicroDSOPs258x.svg" alt="c1 = cT−1→ (a1)  " class="math";align="absmiddle"> we could
calculate the ‘marginal propensity to have consumed’ <img 
src="SolvingMicroDSOPs259x.svg" alt="ϰ1 =  `caT−1 (a1)
          →  " class="math";align="absmiddle"> and construct the
approximation as the linear extrapolation below <img 
src="SolvingMicroDSOPs260x.svg" alt="a
 1   " class="math";align="absmiddle">:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs261x.svg" alt="`cT−1→ (aT−1) ≡ c1 + (aT−1 − a1)ϰ1
" class="math-display" ><a 
 id="x1-14001r32"></a></div>
  </td><td class="equation-label">(32)</td></tr></table>
<!--l. 848--><p class="nopar" >for values of <img 
src="SolvingMicroDSOPs262x.svg" alt="aT−1 &#x003C; a1   " class="math";align="absmiddle"> To see that this approach will lead us into diﬃculties, consider what
happens to the true (not approximated) <img 
src="SolvingMicroDSOPs263x.svg" alt="va    (a    )
 T −1→  T− 1  " class="math";align="absmiddle"> as <img 
src="SolvingMicroDSOPs264x.svg" alt="a
 T−1   " class="math";align="absmiddle"> approaches the value
<img 
src="SolvingMicroDSOPs265x.svg" alt="             −1
aT −1 = − 𝜃ℛ T  " class="math";align="absmiddle">. From (<a 
href="#x1-12005r27">27<!--tex4ht:ref: eq:vEndPrimeTm1 --></a>) we have
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs266x.svg" alt="                                    ( 1 ) ∑n𝜃               −ρ
   lim    vaT−1→ (aT−1) =    lim    βR   ---     (aT− 1ℛT  + 𝜃i)   .
aT−1↓aT− 1               aT−1↓aT− 1     n𝜃   i=1
" class="math-display" ><a 
 id="x1-14002r33"></a></div>
  </td><td class="equation-label">(33)</td></tr></table>
<!--l. 856--><p class="nopar" >
<!--l. 859--><p class="indent" >  But since <img 
src="SolvingMicroDSOPs267x.svg" alt="𝜃-=  𝜃1   " class="math";align="absmiddle">, exactly at <img 
src="SolvingMicroDSOPs268x.svg" alt="aT−1 = aT −1   " class="math";align="absmiddle"> the ﬁrst term in the summation would be
<img 
src="SolvingMicroDSOPs269x.svg" alt="(− 𝜃-+ 𝜃1)−ρ = 1∕0ρ  " class="math";align="absmiddle"> which is inﬁnity. The reason is simple: <img 
src="SolvingMicroDSOPs270x.svg" alt="− aT −1   " class="math";align="absmiddle"> is the PDV, as of
<img 
src="SolvingMicroDSOPs271x.svg" alt="T −  1  " class="math";align="absmiddle">, of the minimum possible realization of income in period <img 
src="SolvingMicroDSOPs272x.svg" alt="T  " class="math";align="absmiddle"> (<img 
src="SolvingMicroDSOPs273x.svg" alt="ℛ   a    = − 𝜃
  T -T−1      1   " class="math";align="absmiddle">). Thus,
if the consumer borrows an amount greater than or equal to <img 
src="SolvingMicroDSOPs274x.svg" alt="   −1
𝜃ℛ T  " class="math";align="absmiddle"> (that is, if the consumer
ends <img 
src="SolvingMicroDSOPs275x.svg" alt="T −  1  " class="math";align="absmiddle"> with <img 
src="SolvingMicroDSOPs276x.svg" alt="            − 1
aT− 1 ≤ − 𝜃-ℛT  " class="math";align="absmiddle">) and then draws the worst possible income shock in period
<img 
src="SolvingMicroDSOPs277x.svg" alt="T  " class="math";align="absmiddle">, they will have to consume zero in period <img 
src="SolvingMicroDSOPs278x.svg" alt="T  " class="math";align="absmiddle">, which yields <img 
src="SolvingMicroDSOPs279x.svg" alt="− ∞ " class="math";align="absmiddle"> utility and <img 
src="SolvingMicroDSOPs280x.svg" alt="∞ " class="math";align="absmiddle">
marginal utility.
<!--l. 872--><p class="indent" >  These reﬂections reveal that the consumer faces a ‘self-imposed’ (or ‘natural’) borrowing
constraint (which springs from the precautionary motive): They will never borrow an amount
greater than or equal to <img 
src="SolvingMicroDSOPs281x.svg" alt="   −1
𝜃ℛ T  " class="math";align="absmiddle"> (that is, assets will never reach the lower bound of
<img 
src="SolvingMicroDSOPs282x.svg" alt="aT −1 " class="math";align="absmiddle">).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs10.html#fn9x0"><sup class="textsuperscript">9</sup></a></span><a 
 id="x1-14003f9"></a>  
The constraint is ‘self-imposed’ in the sense that if the utility function were diﬀerent (say,
Constant Absolute Risk Aversion), the consumer would be willing to borrow more than <img 
src="SolvingMicroDSOPs283x.svg" alt="   −1
𝜃ℛ T  " class="math";align="absmiddle">
because a choice of zero or negative consumption in period <img 
src="SolvingMicroDSOPs284x.svg" alt="T  " class="math";align="absmiddle"> would yield some ﬁnite amount
of utility.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs11.html#fn10x0"><sup class="textsuperscript">10</sup></a></span><a 
 id="x1-14005f10"></a>  
                                                                                     
                                                                                     
<!--l. 889--><p class="indent" >  This self-imposed constraint cannot be captured well when the <img 
src="SolvingMicroDSOPs285x.svg" alt=" a
vT− 1→ " class="math";align="absmiddle"> function is
approximated by a piecewise linear function like <img 
src="SolvingMicroDSOPs286x.svg" alt="`vmT− 1→ " class="math";align="absmiddle">, because there is no chance that the
linear extrapolation below <img 
src="SolvingMicroDSOPs287x.svg" alt="a-  " class="math";align="absmiddle"> will correctly predict <img 
src="SolvingMicroDSOPs288x.svg" alt="va    (a-  ) = ∞.
 T− 1→   T−1  " class="math";align="absmiddle"> To see what will
happen instead, note ﬁrst that if we are approximating <img 
src="SolvingMicroDSOPs289x.svg" alt="va
 T− 1→ " class="math";align="absmiddle"> the smallest value in
<span 
class="ectt-1200">aVec </span>must be greater than <img 
src="SolvingMicroDSOPs290x.svg" alt="aT −1   " class="math";align="absmiddle"> (because the expectation for any <img 
src="SolvingMicroDSOPs291x.svg" alt="aT−1 ≤ aT −1   " class="math";align="absmiddle"> is
undeﬁned).
<!--l. 897--><p class="indent" >  Then when the approximating <img 
src="SolvingMicroDSOPs292x.svg" alt="vaT−1→ " class="math";align="absmiddle"> function is evaluated at some value less than the ﬁrst
element in <span 
class="ectt-1200">aVec</span>, the approximating function will linearly extrapolate the slope that
characterized the lowest segment of the piecewise linear approximation (between <span 
class="ectt-1200">aVec[1] </span>and
<span 
class="ectt-1200">aVec[2]</span>), a procedure that will return a positive ﬁnite number, even if the requested <img 
src="SolvingMicroDSOPs293x.svg" alt="aT− 1   " class="math";align="absmiddle">
point is below <img 
src="SolvingMicroDSOPs294x.svg" alt="aT−1   " class="math";align="absmiddle">. This means that the precautionary saving motive is understated, and by
an arbitrarily large amount as the level of assets approaches its true theoretical minimum
<img 
src="SolvingMicroDSOPs295x.svg" alt="a-
 T −1 " class="math";align="absmiddle">.
<!--l. 909--><p class="indent" >  The foregoing logic demonstrates that the marginal value of saving approaches inﬁnity as
<img 
src="SolvingMicroDSOPs296x.svg" alt="                    −1
aT −1 ↓ aT −1 = − 𝜃-ℛ T  " class="math";align="absmiddle">. But this implies that <img 
src="SolvingMicroDSOPs297x.svg" alt="                             a           −1∕ρ
limaT −1↓aT− 1 cT−1→ (aT −1) = (vT−1→ (aT−1))   =  0  " class="math";align="absmiddle">;
that is, as <img 
src="SolvingMicroDSOPs298x.svg" alt="a  " class="math";align="absmiddle"> approaches its minimum possible value, the corresponding amount of <img 
src="SolvingMicroDSOPs299x.svg" alt="c  " class="math";align="absmiddle"> must
approach <span 
class="ecti-1200">its </span>minimum possible value: zero.
<!--l. 916--><p class="indent" >  The upshot of this discussion is a realization that all we need to do is to augment each of
the <img 
src="SolvingMicroDSOPs300x.svg" alt="aaaT− 1   " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs301x.svg" alt="cccT− 1   " class="math";align="absmiddle"> vectors with an extra point so that the ﬁrst element in the list used
to produce our interpolation function is <img 
src="SolvingMicroDSOPs302x.svg" alt="{aT −1,0.} " class="math";align="absmiddle">. This is done in section “The
Self-Imposed ‘Natural’ Borrowing Constraint and the <img 
src="SolvingMicroDSOPs303x.svg" alt="aT −1   " class="math";align="absmiddle"> Lower Bound” of the
notebook.
<!--l. 922--><p class="indent" >  <a 
 id="GothVInvVSGothC"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-140079"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVInvVSGothC.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 9: </span><span  
class="content">True <img 
src="SolvingMicroDSOPs304x.svg" alt="cT−1 (aT −1)
    →  " class="math";align="absmiddle"> vs its approximation <img 
src="SolvingMicroDSOPs305x.svg" alt="`cT−1 (aT −1)
    →  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-140079 -->                        <span 
class="ecrm-0600">{ﬁg:GothVInvVSGothC}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 930--><p class="indent" >  From there, we plot the lists that have been prepended with the natural borrowing contraint
and the associated minimal level of consumption. Figure <a 
href="#x1-140079">9<!--tex4ht:ref: fig:GothVInvVSGothC --></a> shows the result. The solid line
calculates the exact numerical value of the consumed function <img 
src="SolvingMicroDSOPs306x.svg" alt="c     (a    )
 T −1→  T− 1  " class="math";align="absmiddle"> while the dashed
line is the linear interpolating approximation <img 
src="SolvingMicroDSOPs307x.svg" alt="`cT−1→ (aT −1).  " class="math";align="absmiddle"> This ﬁgure illustrates the value of
the transformation: The true function is close to linear, and so the linear approximation is
almost indistinguishable from the true function except at the very lowest values of
<img 
src="SolvingMicroDSOPs308x.svg" alt="aT −1   " class="math";align="absmiddle">.
<!--l. 932--><p class="indent" >  Figure <a 
href="#x1-1400810">10<!--tex4ht:ref: fig:GothVVSGothCInv --></a> similarly shows that when we generate <img 
src="SolvingMicroDSOPs309x.svg" alt="`a
`vT−1→ (a )  " class="math";align="absmiddle"> using our augmented
<img 
src="SolvingMicroDSOPs310x.svg" alt="          −ρ
[`cT−1→ (a)]  " class="math";align="absmiddle"> (dashed line) we obtain a <span 
class="ecti-1200">much </span>closer approximation to the true function
<img 
src="SolvingMicroDSOPs311x.svg" alt="vaT −1→(a)  " class="math";align="absmiddle"> (solid line) than we did in the previous program which did not do the
transformation (Figure <a 
href="#x1-120067">7<!--tex4ht:ref: fig:PlotOPRawVSFOC --></a>). (The vertical axis label uses <img 
src="SolvingMicroDSOPs312x.svg" alt="𝔳′ " class="math";align="absmiddle"> as an alternative notation for
what in these notes we designate as <img 
src="SolvingMicroDSOPs313x.svg" alt="va
 T→ " class="math";align="absmiddle">).
<!--l. 940--><p class="indent" >  <a 
 id="GothVVSGothCInv"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1400810"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVVSGothCInv.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 10: </span><span  
class="content">True <img 
src="SolvingMicroDSOPs314x.svg" alt="va    (aT−1)
 T−1→  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs315x.svg" alt="``va    (aT −1)
 T−1→  " class="math";align="absmiddle"> Constructed Using <img 
src="SolvingMicroDSOPs316x.svg" alt="`cT−1  (aT−1)
    →  " class="math";align="absmiddle"></span></figcaption><!--tex4ht:label?: x1-1400810 -->      <span 
class="ecrm-0600">{ﬁg:GothVVSGothCInv}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 949--><p class="indent" >  <a 
 id="The-Method-of-Endogenous-Gridpoints"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.8  </span> <a 
 id="x1-150005.8"></a>The Method of Endogenous Gridpoints</h4>
<!--l. 952--><p class="noindent" >Our solution procedure for <img 
src="SolvingMicroDSOPs317x.svg" alt="c
 T− 1   " class="math";align="absmiddle"> still requires us, for each point in <img 
src="SolvingMicroDSOPs318x.svg" alt="mmm
  T−1  " class="math";align="absmiddle"> ( in the
code), to use a numerical rootﬁnding algorithm to search for the value of <img 
src="SolvingMicroDSOPs319x.svg" alt="cT−1   " class="math";align="absmiddle"> that
solves <img 
src="SolvingMicroDSOPs320x.svg" alt=" c          a
u (cT−1) = vT−1→ (mT −1 − cT−1)  " class="math";align="absmiddle">. Unfortunately, rootﬁnding is a notoriously
computation-intensive (that is, slow!) operation.
<!--l. 959--><p class="indent" >  It turns out that there is a way to completely skip the rootﬁnding step. The method can be
understood by noting that any arbitrary value of <img 
src="SolvingMicroDSOPs321x.svg" alt="aaa
 T−1  " class="math";align="absmiddle"> (greater than its lower bound value
<img 
src="SolvingMicroDSOPs322x.svg" alt="a1   " class="math";align="absmiddle">) will be associated with <span 
class="ecti-1200">some </span>marginal valuation as of the continuation (<img 
src="SolvingMicroDSOPs323x.svg" alt="→ " class="math";align="absmiddle">) stage of
<img 
src="SolvingMicroDSOPs324x.svg" alt="T −  1  " class="math";align="absmiddle"> (that is, at the end of the period), and the further observation that it is trivial to
ﬁnd the value of <img 
src="SolvingMicroDSOPs325x.svg" alt="c  " class="math";align="absmiddle"> that yields the same marginal valuation, using the ﬁrst order
condition,
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs326x.svg" alt="uc(cccT−1) = vaT−1→ (aaaT−1)
" class="math-display" ><a 
 id="x1-15001r34"></a></div>
  </td><td class="equation-label">(34)</td></tr></table>
<!--l. 963--><p class="nopar" >by using the inverse of the marginal utility function,
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs327x.svg" alt="c−ρ = μ
       − 1∕ρ
  c = μ
" class="math-display" ><a 
 id="x1-15002r35"></a></div>
  </td><td class="equation-label">(35)</td></tr></table>
                                                                                     
                                                                                     
<!--l. 968--><p class="nopar" >which yields the level of consumption that corresponds to marginal utility of <img 
src="SolvingMicroDSOPs328x.svg" alt="μ.  " class="math";align="absmiddle"> Using this to
invert both sides of (<a 
href="#x1-15001r34">34<!--tex4ht:ref: eq:eulerTm1 --></a>), we get
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs329x.svg" alt="       (            )− 1∕ρ
cccT−1 =  vaT− 1→ (aaaT− 1)
" class="math-display" ><a 
 id="x1-15003r36"></a></div>
  </td><td class="equation-label">(36)</td></tr></table>
<!--l. 976--><p class="nopar" >where the <img 
src="SolvingMicroDSOPs330x.svg" alt="→ " class="math";align="absmiddle"> emphasizes that these are points on the ‘consumed’ function (that is, the
function that reveals how much an optimizing consumer must have consumed in order to end
the period with <img 
src="SolvingMicroDSOPs331x.svg" alt="aT −1,i  " class="math";align="absmiddle">).
<!--l. 979--><p class="indent" >  But with mutually consistent values of <img 
src="SolvingMicroDSOPs332x.svg" alt="cccT−1  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs333x.svg" alt="aaaT− 1  " class="math";align="absmiddle"> (consistent, in the sense that they
are the unique optimal values that correspond to the solution to the problem), we can obtain
the <img 
src="SolvingMicroDSOPs334x.svg" alt="mmmT −1  " class="math";align="absmiddle"> vector that corresponds to both of them from
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs335x.svg" alt="mmmT −1 = cccT−1 + aaaT−1.
" class="math-display" ><a 
 id="x1-15004r37"></a></div>
  </td><td class="equation-label">(37)</td></tr></table>
<!--l. 984--><p class="nopar" >
  <div class="marginpar">
<!--l. 986--><p class="indent" >  <span 
class="ecrm-0600">Rename gothic class: EndStep</span></div>
<!--l. 989--><p class="indent" >  These <img 
src="SolvingMicroDSOPs336x.svg" alt="mT −1   " class="math";align="absmiddle"> gridpoints are “endogenous” in contrast to the usual solution method
of specifying some <span 
class="ecti-1200">ex-ante </span>grid of values of <img 
src="SolvingMicroDSOPs337x.svg" alt="mT −1   " class="math";align="absmiddle"> and then using a rootﬁnding
routine to locate the corresponding optimal <img 
src="SolvingMicroDSOPs338x.svg" alt="cT−1   " class="math";align="absmiddle">. This routine is performed in the
“Endogenous Gridpoints” section of the notebook. First, the <span 
class="ectt-1200">gothic.C_Tminus1</span>
function is called for each of the pre-specﬁed values of end-of-period assets stored
in <span 
class="ectt-1200">aVec</span>. These values of consumption and assets are used to produce the list of
endogenous gridpoints, stored in the object <span 
class="ectt-1200">mVec_egm</span>. With the <img 
src="SolvingMicroDSOPs339x.svg" alt="cccT− 1→ " class="math";align="absmiddle"> values
                                                                                     
                                                                                     
in hand, the notebook can generate a set of <img 
src="SolvingMicroDSOPs340x.svg" alt="mmmT −1  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs341x.svg" alt="cccT−1  " class="math";align="absmiddle"> pairs that can be
interpolated between in order to yield <img 
src="SolvingMicroDSOPs342x.svg" alt="`cT− 1(mT  −1)  " class="math";align="absmiddle"> at virtually zero computational
cost!<span class="footnote-mark"><a 
href="SolvingMicroDSOPs12.html#fn11x0"><sup class="textsuperscript">11</sup></a></span><a 
 id="x1-15005f11"></a>  
<!--l. 998--><p class="indent" >  One might worry about whether the <img 
src="SolvingMicroDSOPs343x.svg" alt="{m, c} " class="math";align="absmiddle"> points obtained in this way will provide a good
representation of the consumption function as a whole, but in practice there are good reasons
why they work well (basically, this procedure generates a set of gridpoints that is
naturally dense right around the parts of the function with the greatest nonlinearity). <a 
 id="PlotComparecTm1AD"></a>
<div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1500711"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/PlotComparecTm1AD.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 11: </span><span  
class="content"><img 
src="SolvingMicroDSOPs344x.svg" alt="cT −1(mT −1)  " class="math";align="absmiddle"> (solid) versus <img 
src="SolvingMicroDSOPs345x.svg" alt="`cT−1(mT −1)  " class="math";align="absmiddle"> (dashed)</span></figcaption><!--tex4ht:label?: x1-1500711 -->                           <span 
class="ecrm-0600">{ﬁg:ComparecTm1AD}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 1009--><p class="indent" >  Figure <a 
href="#x1-1500711">11<!--tex4ht:ref: fig:ComparecTm1AD --></a> plots the actual consumption function <img 
src="SolvingMicroDSOPs346x.svg" alt="cT−1   " class="math";align="absmiddle"> and the approximated consumption
function <img 
src="SolvingMicroDSOPs347x.svg" alt="`cT−1   " class="math";align="absmiddle"> derived by the method of endogenous grid points. Compared to the
approximate consumption functions illustrated in Figure <a 
href="#x1-120078">8<!--tex4ht:ref: fig:PlotcTm1ABC --></a>, <img 
src="SolvingMicroDSOPs348x.svg" alt="`c
 T− 1   " class="math";align="absmiddle"> is quite close to the actual
consumption function.
<!--l. 1018--><p class="indent" >  <a 
 id="Improving-the-a-Grid"></a>
  <h4 class="subsectionHead"><span class="titlemark">5.9  </span> <a 
 id="x1-160005.9"></a>Improving the <img 
src="SolvingMicroDSOPs349x.svg" alt="a  " class="math";align="absmiddle"> Grid</h4>
<!--l. 1021--><p class="noindent" >Thus far, we have arbitrarily used <img 
src="SolvingMicroDSOPs350x.svg" alt="a  " class="math";align="absmiddle"> gridpoints of <img 
src="SolvingMicroDSOPs351x.svg" alt="{0.,1.,2.,3.,4.} " class="math";align="absmiddle"> (augmented in
the last subsection by <img 
src="SolvingMicroDSOPs352x.svg" alt="a
-T−1   " class="math";align="absmiddle">). But it has been obvious from the ﬁgures that the
approximated <img 
src="SolvingMicroDSOPs353x.svg" alt="`cT −1→ " class="math";align="absmiddle"> function tends to be farthest from its true value <img 
src="SolvingMicroDSOPs354x.svg" alt="cT−1→ " class="math";align="absmiddle"> at
low values of <img 
src="SolvingMicroDSOPs355x.svg" alt="a  " class="math";align="absmiddle">. Combining this with our insight that <img 
src="SolvingMicroDSOPs356x.svg" alt="aT−1   " class="math";align="absmiddle"> is a lower bound, we
are now in position to deﬁne a more deliberate method for constructing gridpoints
for <img 
src="SolvingMicroDSOPs357x.svg" alt="aT−1   " class="math";align="absmiddle"> – a method that yields values that are more densely spaced than the
uniform grid at low values of <img 
src="SolvingMicroDSOPs358x.svg" alt="a  " class="math";align="absmiddle">. A pragmatic choice that works well is to ﬁnd the
values such that (1) the last value <span 
class="ecti-1200">exceeds the lower bound </span>by the same amount
<img 
src="SolvingMicroDSOPs359x.svg" alt="¯aT −1   " class="math";align="absmiddle"> as our original maximum gridpoint (in our case, 4.); (2) we have the same
number of gridpoints as before; and (3) the <span 
class="ecti-1200">multi-exponential growth rate </span>(that is,
<img 
src="SolvingMicroDSOPs360x.svg" alt="   ...
eee   " class="math";align="absmiddle"> for some number of exponentiations <img 
src="SolvingMicroDSOPs361x.svg" alt="n 𝜃  " class="math";align="absmiddle">) from each point to the next point is
constant (instead of, as previously, imposing constancy of the absolute gap between
points).
<!--l. 1038--><p class="indent" >  <a 
 id="GothVInvVSGothCEEE"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600112"></a>
                                                                                     
                                                                                     
<div  
class="centerline">                                         <img 
src="./Figures/GothVInvVSGothCEEE.png" alt="pict"  
 width="433.62pt" >                                         </div>
<figcaption class="caption" ><span class="id">Figure 12: </span><span  
class="content"><img 
src="SolvingMicroDSOPs362x.svg" alt="cT −1 (aT− 1)
     →  " class="math";align="absmiddle"> versus <img 
src="SolvingMicroDSOPs363x.svg" alt="`cT −1 (aT− 1)
     →  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1600112 -->                 <span 
class="ecrm-0600">{ﬁg:GothVInvVSGothCEE}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 1047--><p class="indent" >  <a 
 id="GothVVSGothCInvEEE"></a>  <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1600213"></a>
                                                                                     
                                                                                     
<!--l. 1049--><p class="noindent" > <img 
src="./Figures/GothVVSGothCInvEEE.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure 13: </span><span  
class="content"><img 
src="SolvingMicroDSOPs364x.svg" alt="vaT−1→(aT −1)  " class="math";align="absmiddle"> vs. <img 
src="SolvingMicroDSOPs365x.svg" alt="``vaT −1→(aT− 1)  " class="math";align="absmiddle">, Multi-Exponential <span 
class="ectt-1200">aVec</span></span></figcaption><!--tex4ht:label?: x1-1600213 -->                    <span 
class="ecrm-0600">{ﬁg:GothVVSGothCInvEE}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 1055--><p class="indent" >  Section “Improve the <img 
src="SolvingMicroDSOPs366x.svg" alt="𝔸grid  " class="math";align="absmiddle">” begins by deﬁning a function which takes as arguments the
speciﬁcations of an initial grid of assets (captured by the arguments <span 
class="ectt-1200">minval</span>, <span 
class="ectt-1200">maxval</span>, and
<span 
class="ectt-1200">size</span>) and returns the new grid incorporating the multi-exponential approach outlined above.
Then, a call is made to this function and the improved grid of assets is stored in the object
<span 
class="ectt-1200">aVec_eee</span>. Lastly, the endogenous gridpoint method described in the previous section is
performed using this new grid of assets. Notice that the graphs depicted in Figures <a 
href="#x1-1600112">12<!--tex4ht:ref: fig:GothVInvVSGothCEE --></a> and <a 
href="#x1-1600213">13<!--tex4ht:ref: fig:GothVVSGothCInvEE --></a>
are notably closer to their respective truths than the corresponding ﬁgures that used the
original grid.
<!--l. 2237--><p class="indent" >  <a 
 id="StructuralEstimation"></a>
  <h3 class="sectionHead"><span class="titlemark">6  </span> <a 
 id="x1-170006"></a>Structural Estimation</h3>                                                             <span 
class="ecrm-0600">{sec:StructEst}</span>
<!--l. 2240--><p class="noindent" >This section describes how to use the methods developed above to structurally
estimate a life-cycle consumption model, following closely the work of
<span 
class="ecbx-1200">?</span>.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs13.html#fn12x0"><sup class="textsuperscript">12</sup></a></span><a 
 id="x1-17001f12"></a>  
The key idea of structural estimation is to look for the parameter values (for the time
preference rate, relative risk aversion, or other parameters) which lead to the best possible
match between simulated and empirical moments.
<!--l. 2251--><p class="indent" >  <a 
 id="LifeCycleModel"></a>
  <h4 class="subsectionHead"><span class="titlemark">6.1  </span> <a 
 id="x1-180006.1"></a>Life Cycle Model</h4>
<!--l. 2255--><p class="noindent" >Realistic calibration of a life cycle model needs to take into account a few things that we
omitted from the bare-bones model described above. For example, the whole point of the life
cycle model is that life is ﬁnite, so we need to include a realistic treatment of life expectancy;
this is done easily enough, by assuming that utility accrues only if you live, so eﬀectively the
rising mortality rate with age is treated as an extra reason for discounting the future.
Similarly, we may want to capture the demographic evolution of the household (e.g., arrival
and departure of kids). A common way to handle that, too, is by modifying the discount
factor (arrival of a kid might increase the total utility of the household by, say, 0.2, so if the
‘pure’ rate of time preference were <img 
src="SolvingMicroDSOPs367x.svg" alt="1.0  " class="math";align="absmiddle"> the ‘household-size-adjusted’ discount factor
might be 1.2. We therefore modify the model presented above to allow age-varying
discount factors that capture both mortality and family-size changes (we just adopt the
factors used by <span 
class="ecbx-1200">? </span>directly), with the probability of remaining alive between <img 
src="SolvingMicroDSOPs368x.svg" alt="t  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs369x.svg" alt="t + n  " class="math";align="absmiddle"> captured by <img 
src="SolvingMicroDSOPs370x.svg" alt="ℒ " class="math";align="absmiddle"> and with <img 
src="SolvingMicroDSOPs371x.svg" alt="ˆβ  " class="math";align="absmiddle"> now reﬂecting all the age-varying discount factor
adjustments (mortality, family-size, etc). Using <img 
src="SolvingMicroDSOPs372x.svg" alt="ℶ  " class="math";align="absmiddle"> (the Hebrew cognate of <img 
src="SolvingMicroDSOPs373x.svg" alt="β  " class="math";align="absmiddle">)
for the ‘pure’ time preference factor, the value function for the revised problem
is
  <table 
class="equation"><tr><td>
                                                                                     
                                                                                     
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs374x.svg" alt="                             [T∑−t                   ]
v (p ,m ) = max   u (c) + 𝔼       ℶnℒt+n ˆβt+nu(c   )
 t  t   t    {c}Tt      t    t          t   t     t+n
                              n=1
" class="math-display" ><a 
 id="x1-18001r38"></a></div>
  </td><td class="equation-label">(38)</td></tr></table>
<!--l. 3--><p class="nopar" >subject to the constraints
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs375x.svg" alt="   at = mt −  ct
 pt+1 = 𝒢t+1ptΨt+1

 yt+1 = pt+1𝜃t+1
mt+1  = Rat + yt+1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 6--><p class="nopar" > where
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs376x.svg" alt="  t+n
ℒ t  : probability to ℒive until age t + n given alive at age t
 ˆt+n
βt   : age -varying discount factor between ages t and t + n
  Ψt : mean -one shock  to permanent   income
   ℶ : time -invariant ‘pure ’ discount factor
" class="math-display" ></div>
  </td></tr></table>
                                                                                     
                                                                                     
<!--l. 6--><p class="nopar" >and all the other variables are deﬁned as in section <a 
href="#x1-20002">2<!--tex4ht:ref: sec:the-problem --></a>.
<!--l. 2284--><p class="indent" >  Households start life at age <img 
src="SolvingMicroDSOPs377x.svg" alt="s = 25  " class="math";align="absmiddle"> and live with probability 1 until retirement (<img 
src="SolvingMicroDSOPs378x.svg" alt="s = 65  " class="math";align="absmiddle">).
Thereafter the survival probability shrinks every year and agents are dead by <img 
src="SolvingMicroDSOPs379x.svg" alt="s = 91  " class="math";align="absmiddle"> as
assumed by Cagetti.
<!--l. 1--><p class="indent" >  Transitory and permanent shocks are distributed as follows:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs380x.svg" alt="         (
         | 0      with probability ℘ &#x003E;  0
         {                                                      2    2
    Ξs = | 𝜃s∕℘   with probability (1 − ℘ ), where log𝜃s ∽ 𝒩  (− σ 𝜃∕2,σ𝜃)
         (
               2     2
logΨs  ∽ 𝒩 (− σΨ ∕2,σΨ )
" class="math-display" ><a 
 id="x1-18002r39"></a></div>
  </td><td class="equation-label">(39)</td></tr></table>
<!--l. 9--><p class="nopar" >where <img 
src="SolvingMicroDSOPs381x.svg" alt="℘  " class="math";align="absmiddle"> is the probability of unemployment (and unemployment shocks are turned oﬀ after
retirement).
<!--l. 2302--><p class="indent" >  The parameter values for the shocks are taken from Carroll (<span 
class="ecbx-1200">?</span>), <img 
src="SolvingMicroDSOPs382x.svg" alt="℘ = 0.5∕100  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs383x.svg" alt="σ 𝜃 = 0.1  " class="math";align="absmiddle">, and
<img 
src="SolvingMicroDSOPs384x.svg" alt="σ Ψ = 0.1  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs14.html#fn13x0"><sup class="textsuperscript">13</sup></a></span><a 
 id="x1-18003f13"></a>   The
income growth proﬁle <img 
src="SolvingMicroDSOPs388x.svg" alt="𝒢t  " class="math";align="absmiddle"> is from Carroll (<span 
class="ecbx-1200">?</span>) and the values of <img 
src="SolvingMicroDSOPs389x.svg" alt="ℒt  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs390x.svg" alt="ˆ
βt  " class="math";align="absmiddle"> are obtained from Cagetti (<span 
class="ecbx-1200">?</span>)
(Figure <a 
href="#x1-1800714">14<!--tex4ht:ref: fig:TimeVaryingParam --></a>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs15.html#fn14x0"><sup class="textsuperscript">14</sup></a></span><a 
 id="x1-18005f14"></a>  
The interest rate is assumed to equal <img 
src="SolvingMicroDSOPs391x.svg" alt="1.03  " class="math";align="absmiddle">. The model parameters are included in Table
<a 
href="#x1-180081">1<!--tex4ht:ref: table:StrEstParams --></a>.
<!--l. 2305--><p class="indent" >  <a 
 id="PlotTimeVaryingParam"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1800714"></a>
                                                                                     
                                                                                     
<!--l. 2307--><p class="noindent" > <img 
src="./Figures/PlotTimeVaryingParam.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure 14: </span><span  
class="content">Time Varying Parameters</span></figcaption><!--tex4ht:label?: x1-1800714 -->                                                   <span 
class="ecrm-0600">{ﬁg:TimeVaryingParam}</span>
                                                                                     
                                                                                     
  </div>
  <div class="table">
                                                                                     
                                                                                     
<!--l. 2312--><p class="indent" >  <a 
 id="x1-180081"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table 1: </span><span  
class="content">Parameter Values</span></figcaption><!--tex4ht:label?: x1-180081 -->                                                             <span 
class="ecrm-0600">{table:StrEstParams}</span>
<div class="center" 
>
<!--l. 2314--><p class="noindent" >
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs392x.svg" alt="--------------------------------
   σ𝜃       0.1      Carroll (?)
  σ Ψ       0.1      Carroll (?)

   ℘       0.005     Carroll (?)
   𝒢s    ﬁgure 14   Carroll (?)
 ˆβs,ℒs   ﬁgure 14   Cagetti (? )
   R       1.03     Cagetti (? )
--------------------------------
" ></div></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 2328--><p class="indent" >  The structural estimation of the parameters <img 
src="SolvingMicroDSOPs393x.svg" alt="ℶ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs394x.svg" alt="ρ  " class="math";align="absmiddle"> is carried out using the procedure
speciﬁed in the following section, which is then implemented in the <span 
class="ectt-1200">StructEstimation.py </span>ﬁle.
This ﬁle consists of two main components. The ﬁrst section deﬁnes the objects required to
execute the structural estimation procedure, while the second section executes the procedure
and various optional experiments with their corresponding commands. The next section
elaborates on the procedure and its accompanying code implementation in greater
detail.
  <h4 class="subsectionHead"><span class="titlemark">6.2  </span> <a 
 id="x1-190006.2"></a>Estimation</h4>
<!--l. 2338--><p class="noindent" >When economists say that they are performing “structural estimation” of a model like this, they
mean that they have devised a formal procedure for searching for values for the parameters <img 
src="SolvingMicroDSOPs395x.svg" alt="ℶ  " class="math";align="absmiddle">
and <img 
src="SolvingMicroDSOPs396x.svg" alt="ρ  " class="math";align="absmiddle"> at which some measure of the model’s outcome (like “median wealth by age”) is as
close as possible to an empirical measure of the same thing. Here, we choose to match the
median of the wealth to permanent income ratio across 7 age groups, from age <img 
src="SolvingMicroDSOPs397x.svg" alt="26 − 30  " class="math";align="absmiddle"> up to
<img 
src="SolvingMicroDSOPs398x.svg" alt="56 − 60  " class="math";align="absmiddle">.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs16.html#fn15x0"><sup class="textsuperscript">15</sup></a></span><a 
 id="x1-19001f15"></a>  
The choice of matching the medians rather the means is motivated by the fact that the wealth
distribution is much more concentrated at the top than the model is capable of
explaining using a single set of parameter values. This means that in practice one
must pick some portion of the population who one wants to match well; since the
model has little hope of capturing the behavior of Bill Gates, but might conceivably
match the behavior of Homer Simpson, we choose to match medians rather than
means.
<!--l. 2360--><p class="indent" >  As explained in section <a 
href="#x1-30003">3<!--tex4ht:ref: sec:normalization --></a>, it is convenient to work with the normalized version of the model
which can be written in Bellman form as:
  <table 
class="equation-star"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs399x.svg" alt="v (m ) = max    u(c ) + ℶ ℒ  βˆ   𝔼 [(Ψ    𝒢   )1−ρv   (m    )]
 t   t     ct       t       t+1  t+1  t   t+1 t+1     t+1   t+1
      s.t.

    at = mt −  ct
           (     R    )
  mt+1 = at  ---------   + 𝜃t+1
           ◟ Ψt+1◝𝒢◜t+1-◞
               ≡ ℛt+1
" class="math-display" ></div>
  </td></tr></table>
<!--l. 7--><p class="nopar" >with the ﬁrst order condition:
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs400x.svg" alt="uc(ct) = ℶℒt+1βˆt+1R 𝔼t [uc (Ψt+1 𝒢t+1ct+1 (atℛt+1  + 𝜃t+1))].
" class="math-display" ><a 
 id="x1-19003r40"></a></div>
  </td><td class="equation-label">(40)</td></tr></table>
<!--l. 4--><p class="nopar" >
<!--l. 2380--><p class="indent" >  The ﬁrst substantive step in this estimation procedure is to solve for the consumption
functions at each age. We need to discretize the shock distribution and solve for the policy
functions by backward induction using equation (<a 
href="#x1-19003r40">40<!--tex4ht:ref: eq:FOCLifeCycle --></a>) following the procedure in sections <a 
href="#x1-70005">5<!--tex4ht:ref: sec:NextToLast --></a> and
<span 
class="ecbx-1200">??</span>. The latter routine is slightly complicated by the fact that we are considering a life-cycle
model and therefore the growth rate of permanent income, the probability of death, the
time-varying discount factor and the distribution of shocks will be diﬀerent across the years.
We thus must ensure that at each backward iteration the right parameter values are
used.
<!--l. 2393--><p class="indent" >  Correspondingly, the ﬁrst part of the <span 
class="ectt-1200">StructEstimation.py </span>ﬁle begins by deﬁning the
agent type by inheriting from the baseline agent type <span 
class="ectt-1200">IndShockConsumerType</span>, with the
modiﬁcation to include time-varying discount factors. Next, an instance of this “life-cycle”
consumer is created for the estimation procedure. The number of periods for the life cycle of a
given agent is set and, following Cagetti,  (<span 
class="ecbx-1200">?</span>), we initialize the wealth to income ratio of
agents at age <img 
src="SolvingMicroDSOPs401x.svg" alt="25  " class="math";align="absmiddle"> by randomly assigning the equal probability values to <img 
src="SolvingMicroDSOPs402x.svg" alt="0.17  " class="math";align="absmiddle">, <img 
src="SolvingMicroDSOPs403x.svg" alt="0.50  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs404x.svg" alt="0.83  " class="math";align="absmiddle">. In particular, we consider a population of agents at age 25 and follow their
consumption and wealth accumulation dynamics as they reach the age of <img 
src="SolvingMicroDSOPs405x.svg" alt="60  " class="math";align="absmiddle">, using the
appropriate age-speciﬁc consumption functions and the age-varying parameters. The simulated
medians are obtained by taking the medians of the wealth to income ratio of the <img 
src="SolvingMicroDSOPs406x.svg" alt="7  " class="math";align="absmiddle"> age
                                                                                     
                                                                                     
groups.
<!--l. 2408--><p class="indent" >  To complete the creation of the consumer type needed for the simulation, a history of shocks
is drawn for each agent across all periods by invoking the <span 
class="ectt-1200">make_shock_history </span>function. This
involves discretizing the shock distribution for as many points as the number of agents we
want to simulate and then randomly permuting this shock vector as many times as we need to
simulate the model for. In this way, we obtain a time varying shock for each agent. This is
much more time eﬃcient than drawing at each time from the shock distribution a shock for
each agent, and also ensures a stable distribution of shocks across the simulation periods even
for a small number of agents. (Similarly, in order to speed up the process, at each backward
iteration we compute the consumption function and other variables as a vector at
once.)
<!--l. 2421--><p class="indent" >  With the age-varying consumption functions derived from the life-cycle agent, we can
proceed to generate simulated data and compute the corresponding medians. Estimating the
model involves comparing these simulated medians with empirical medians, measuring the
model’s success by calculating the diﬀerence between the two. However, before performing the
necessary steps of solving and simulating the model to generate simulated moments, it’s
important to note a diﬃculty in producing the target moments using the available
data.
<!--l. 2429--><p class="indent" >  Speciﬁcally, deﬁning <img 
src="SolvingMicroDSOPs407x.svg" alt="ξ  " class="math";align="absmiddle"> as the set of parameters to be estimated (in the current case
<img 
src="SolvingMicroDSOPs408x.svg" alt="ξ = {ρ, ℶ} " class="math";align="absmiddle">), we could search for the parameter values which solve
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs409x.svg" alt="    ∑ 7
min     |ςτ − sτ(ξ)|
  ξ τ=1
" class="math-display" ><a 
 id="x1-19004r41"></a></div>
  </td><td class="equation-label">(41)</td></tr></table>
<!--l. 7--><p class="nopar" >where <img 
src="SolvingMicroDSOPs410x.svg" alt="ςτ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs411x.svg" alt="sτ  " class="math";align="absmiddle"> are respectively the empirical and simulated medians of the wealth to
permanent income ratio for age group <img 
src="SolvingMicroDSOPs412x.svg" alt="τ  " class="math";align="absmiddle">. A drawback of proceeding in this way is that it
treats the empirically estimated medians as though they reﬂected perfect measurements of the
truth. Imagine, however, that one of the age groups happened to have (in the consumer
survey) four times as many data observations as another age group; then we would expect the
median to be more precisely estimated for the age group with more observations; yet (<a 
href="#x1-19004r41">41<!--tex4ht:ref: eq:naivePowell --></a>)
assigns equal importance to a deviation between the model and the data for all age
groups.
<!--l. 2453--><p class="indent" >  We can get around this problem (and a variety of others) by instead minimizing a slightly
more complex object:
                                                                                     
                                                                                     
  <table 
class="equation"><tr><td>
  <div class="math-display" >
<img 
src="SolvingMicroDSOPs413x.svg" alt="    ∑N
min     ωi|ςτi − sτ(ξ)|
 ξ   i
" class="math-display" ><a 
 id="x1-19005r42"></a></div>
  </td><td class="equation-label">(42)</td></tr></table>
<!--l. 3--><p class="nopar" >where <img 
src="SolvingMicroDSOPs414x.svg" alt="ωi  " class="math";align="absmiddle">  is the weight of household <img 
src="SolvingMicroDSOPs415x.svg" alt="i  " class="math";align="absmiddle"> in the entire
population,<span class="footnote-mark"><a 
href="SolvingMicroDSOPs17.html#fn16x0"><sup class="textsuperscript">16</sup></a></span><a 
 id="x1-19006f16"></a>  
and <img 
src="SolvingMicroDSOPs416x.svg" alt="ςiτ  " class="math";align="absmiddle"> is the empirical wealth to permanent income ratio of household <img 
src="SolvingMicroDSOPs417x.svg" alt="i  " class="math";align="absmiddle"> whose head
belongs to age group <img 
src="SolvingMicroDSOPs418x.svg" alt="τ  " class="math";align="absmiddle">. <img 
src="SolvingMicroDSOPs419x.svg" alt="ω
  i  " class="math";align="absmiddle"> is needed because unequal weight is assigned to each observation
in the Survey of Consumer Finances (SCF). The absolute value is used since the formula is
based on the fact that the median is the value that minimizes the sum of the absolute
deviations from itself.
<!--l. 2476--><p class="indent" >  With this in mind, we turn our attention to the computation of the weighted median
wealth target moments for each age cohort using this data from the 2004 Survery of
Consumer Finances on household wealth. The objects necessary to accomplish this
task are <span 
class="ectt-1200">weighted_median </span>and <span 
class="ectt-1200">get_targeted_moments</span>. The actual data are taken
from several waves of the SCF and the medians and means for each age category
are plotted in ﬁgure <a 
href="#x1-1900815">15<!--tex4ht:ref: fig:MeanMedianSCF --></a>. More details on the SCF data are included in appendix
<a 
href="#x1-23000A">A<!--tex4ht:ref: app:SCFdata --></a>.
<!--l. 2484--><p class="indent" >  <a 
 id="PlotMeanMedianSCFcollegeGrads"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-1900815"></a>
                                                                                     
                                                                                     
<!--l. 2487--><p class="noindent" > <img 
src="./Figures/PlotMeanMedianSCFcollegeGrads.png" alt="pict"  
 width="433.62pt" >
<figcaption class="caption" ><span class="id">Figure 15: </span><span  
class="content">Wealth to Permanent Income Ratios from SCF (means (dashed) and medians
(solid))</span></figcaption><!--tex4ht:label?: x1-1900815 -->                                                                                <span 
class="ecrm-0600">{ﬁg:MeanMedianSCF}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 2492--><p class="indent" >  We now turn our attention to the the two key functions in this section of the code ﬁle. The
ﬁrst, <span 
class="ectt-1200">simulate_moments</span>, executes the solving (<span 
class="ectt-1200">solve</span>) and simulation (<span 
class="ectt-1200">simulation</span>)
steps for the deﬁned life-cycle agent. Subsequently, the function uses the agents’
tracked levels of wealth based on their optimal consumption behavior to compute
and store the simulated median wealth to income ratio for each age cohort. The
second function, <span 
class="ectt-1200">smmObjectiveFxn</span>, calls the <span 
class="ectt-1200">simulate_moments </span>function to create
the objective function described in (<a 
href="#x1-19005r42">42<!--tex4ht:ref: eq:StructEstim --></a>), which is necessary to perform the SMM
estimation.
<!--l. 2515--><p class="indent" >  Thus, for a given pair of the parameters to be estimated, the single call to the function
<span 
class="ectt-1200">smmObjectiveFxn </span>executes the following:
      <ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-19010x1">
      <!--l. 2518--><p class="noindent" >solves for the consumption functions for the life-cycle agent
      </li>
<li 
  class="enumerate" id="x1-19012x2">
      <!--l. 2519--><p class="noindent" >simulates the data and computes the simulated medians
      </li>
<li 
  class="enumerate" id="x1-19014x3">
      <!--l. 2520--><p class="noindent" >returns the value of equation (<a 
href="#x1-19005r42">42<!--tex4ht:ref: eq:StructEstim --></a>)</li></ol>
<!--l. 2523--><p class="indent" >  We delegate the task of ﬁnding the coeﬃcients that minimize the <span 
class="ectt-1200">smmObjectiveFxn</span>
function to the <span 
class="ectt-1200">minimize_nelder_mead </span>function, which is deﬁned elsewhere and called in the
second part of this ﬁle. This task can be quite time demanding and rather problematic if the
<span 
class="ectt-1200">smmObjectiveFxn </span>function has very ﬂat regions or sharp features. It is thus wise to verify the
accuracy of the solution, for example by experimenting with a variety of alternative starting
values for the parameter search.
<!--l. 2532--><p class="indent" >  The ﬁnal object deﬁned in this ﬁrst part of the <span 
class="ectt-1200">StructEstimation.py</span>
ﬁle is <span 
class="ectt-1200">calculateStandardErrorsByBootstrap</span>. As the name suggsts,
the purpose of this function is to compute the standard errors by
bootstrap.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs18.html#fn17x0"><sup class="textsuperscript">17</sup></a></span><a 
 id="x1-19015f17"></a>  
This involves:
      <ol  class="enumerate1" >
<li 
  class="enumerate" id="x1-19018x1">
      <!--l. 2538--><p class="noindent" >drawing new shocks for the simulation
                                                                                     
                                                                                     
      </li>
<li 
  class="enumerate" id="x1-19020x2">
      <!--l. 2539--><p class="noindent" >drawing a random sample (with replacement) of actual data from the SCF
      </li>
<li 
  class="enumerate" id="x1-19022x3">
      <!--l. 2540--><p class="noindent" >obtaining new estimates for <img 
src="SolvingMicroDSOPs420x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs421x.svg" alt="ℶ  " class="math";align="absmiddle"></li></ol>
<!--l. 2542--><p class="noindent" >We repeat the above procedure several times (<span 
class="ectt-1200">Bootstrap</span>) and take the standard deviation for
each of the estimated parameters across the various bootstrap iterations.
  <h5 class="subsubsectionHead"><span class="titlemark">6.2.1  </span> <a 
 id="x1-200006.2.1"></a>An Aside to Computing Sensitivity Measures</h5>                                   <span 
class="ecrm-0600">{subsubsec:sensmeas}</span>
<!--l. 2547--><p class="noindent" >A common drawback in commonly used structural estimation procedures is a lack of
transparency in its estimates. As <span 
class="ecbx-1200">? </span>notes, a researcher employing such structural empirical
methods may be interested in how alternative assumptions (such as misspeciﬁcation or
measurement bias in the data) would “change the moments of the data that the estimator uses
as inputs, and how changes in these moments aﬀect the estimates.” The authors provide a
measure of sensitivity for given estimator that makes it easy to map the eﬀects of diﬀerent
assumptions on the moments into predictable bias in the estimates for non-linear
models.
<!--l. 2554--><p class="indent" >  In the language of <span 
class="ecbx-1200">?</span>, section <a 
href="#x1-170006">6<!--tex4ht:ref: sec:StructEst --></a> is aimed at providing an estimator <img 
src="SolvingMicroDSOPs422x.svg" alt="ξ = {ρ,ℶ } " class="math";align="absmiddle"> that has some
true value <img 
src="SolvingMicroDSOPs423x.svg" alt="ξ0   " class="math";align="absmiddle"> by assumption. Under the assumption <img 
src="SolvingMicroDSOPs424x.svg" alt="a0   " class="math";align="absmiddle"> of the researcher, the empirical
targets computed from the SCF is measured accurately. These moments of the data are
precisely what determine our estimate <img 
src="SolvingMicroDSOPs425x.svg" alt="ˆ
ξ " class="math";align="absmiddle">, which minimizes (<a 
href="#x1-19005r42">42<!--tex4ht:ref: eq:StructEstim --></a>). Under alternative
assumptions <img 
src="SolvingMicroDSOPs426x.svg" alt="a  " class="math";align="absmiddle">, such that a given cohort is mismeasured in the survey, a diﬀerent
estimate is computed. Using the plug-in estimate provided by the authors, we can see
quantitatively how our estimate changes under these alternative assumptions <img 
src="SolvingMicroDSOPs427x.svg" alt="a  " class="math";align="absmiddle"> which
correspond to mismeasurement in the median wealth to income ratio for a given age
cohort.
<!--l. 2562--><p class="noindent" >
  <h4 class="subsectionHead"><span class="titlemark">6.3  </span> <a 
 id="x1-210006.3"></a>Results</h4>
<!--l. 2563--><p class="noindent" >The second part of the ﬁle <span 
class="ectt-1200">StructEstimation.py </span>deﬁnes a function <span 
class="ectt-1200">main </span>which produces
our <img 
src="SolvingMicroDSOPs428x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs429x.svg" alt="ℶ  " class="math";align="absmiddle"> estimates with standard errors using 10,000 simulated agents by
setting the positional arguments <span 
class="ectt-1200">estimate_model </span>and <span 
class="ectt-1200">compute_standard_errors </span>to
                                                                                     
                                                                                     
true.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs19.html#fn18x0"><sup class="textsuperscript">18</sup></a></span><a 
 id="x1-21001f18"></a>   Results are
reported in Table <a 
href="#x1-210052">2<!--tex4ht:ref: tab:EstResults --></a>.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs20.html#fn19x0"><sup class="textsuperscript">19</sup></a></span><a 
 id="x1-21003f19"></a>  
  <div class="table">
                                                                                     
                                                                                     
<!--l. 1--><p class="indent" >  <a 
 id="x1-210052"></a><figure class="float" 
>
                                                                                     
                                                                                     
<figcaption class="caption" ><span class="id">Table 2: </span><span  
class="content">Estimation Results</span></figcaption><!--tex4ht:label?: x1-210052 -->                                                            <span 
class="ecrm-0600">{tab:EstResults}</span>
<div class="pic-tabular">
<img 
src="SolvingMicroDSOPs432x.svg" alt="-------------------
----ρ--------ℶ-----
  3.69      0.88
 (0.047)  (0.002)
-------------------
" ></div>
                                                                                     
                                                                                     
  </figure>
  </div>
<!--l. 2595--><p class="indent" >  The literature on consumption and savings behavior over the lifecycle in the presenece of labor income
uncertainty <span class="footnote-mark"><a 
href="SolvingMicroDSOPs21.html#fn20x0"><sup class="textsuperscript">20</sup></a></span><a 
 id="x1-21006f20"></a>  
warns us to be careful in disentangling the eﬀect of time preference and risk aversion when
describing the optimal behavior of households in this setting. Since the precautionary saving
motive dominates in the early stages of life, the coeﬃcient of relative risk aversion (as well
as expected labor income growth) has a larger eﬀect on optimal consumption and
saving behavior through their magnitude relative to the interest rate. Over time,
life-cycle considerations (such as saving for retirement) become more important and the
time preference factor plays a larger role in determining optimal behavior for this
cohort.
<!--l. 2605--><p class="indent" >  Using the positional argument <span 
class="ectt-1200">compute_sensitivity</span>, Figure <a 
href="#x1-2100816">16<!--tex4ht:ref: fig:PlotSensitivityMeasure --></a> provides a plot of the
plug-in estimate of the sensitivity measure described in <a 
href="#x1-200006.2.1">6.2.1<!--tex4ht:ref: subsubsec:sensmeas --></a>. As you can see from the ﬁgure
the inverse relationship between <img 
src="SolvingMicroDSOPs433x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs434x.svg" alt="ℶ  " class="math";align="absmiddle"> over the life-cycle is retained by the sensitivity
measure. Speciﬁcally, under the alternative assumption that <span 
class="ecti-1200">a particular cohort is</span>
<span 
class="ecti-1200">mismeasured in the SCF dataset</span>, we see that the y-axis suggests that our estimate of <img 
src="SolvingMicroDSOPs435x.svg" alt="ρ  " class="math";align="absmiddle"> and
<img 
src="SolvingMicroDSOPs436x.svg" alt="ℶ  " class="math";align="absmiddle"> change in a predictable way.
<!--l. 2612--><p class="indent" >  Suppose that there are not enough observations of the oldest cohort of households in the
sample. Suppose further that the researcher predicts that adding more observations of these
households to correct this mismeasurement would correspond to a higher median wealth to
income ratio for this cohort. In this case, our estimate of the time preference factor should
increase: the behavior of these older households is driven by their time preference, so a
higher value of <img 
src="SolvingMicroDSOPs437x.svg" alt="ℶ  " class="math";align="absmiddle"> is required to match the aﬀected wealth to income targets under
this alternative assumption. Since risk aversion is less important in explaining the
behavior of this cohort, a lower value of <img 
src="SolvingMicroDSOPs438x.svg" alt="ρ  " class="math";align="absmiddle"> is required to match the aﬀected empirical
moments.
<!--l. 2621--><p class="indent" >  To recap, the sensitivity measure not only matches our intuition about the inverse
relationship between <img 
src="SolvingMicroDSOPs439x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs440x.svg" alt="ℶ  " class="math";align="absmiddle"> over the life-cycle, but provides a quantitative estimate of
what would happen to our estimates of these parameters under the alternative assumption
that the data is mismeasured in some way.
<!--l. 2625--><p class="indent" >  <a 
 id="PlotSensitivityMeasure"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2100816"></a>
                                                                                     
                                                                                     
<!--l. 2627--><p class="noindent" > <img 
src="./Figures/Sensitivity-.svg" alt="PIC"  
style="width:96.76%">
<figcaption class="caption" ><span class="id">Figure 16:  </span><span  
class="content">Sensitivty  of  Estimates  <img 
src="SolvingMicroDSOPs441x.svg" alt="{ρ, ℶ} " class="math";align="absmiddle"> regarding  Alternative  Mismeasurement
Assumptions.</span></figcaption><!--tex4ht:label?: x1-2100816 -->                                                                          <span 
class="ecrm-0600">{ﬁg:PlotSensitivityMeasure}</span>
                                                                                     
                                                                                     
  </div>
<!--l. 2632--><p class="indent" >  By setting the positional argument <span 
class="ectt-1200">make_contour_plot </span>to true, Figure <a 
href="#x1-2200117">17<!--tex4ht:ref: fig:PlotContourMedianStrEst --></a> shows the
contour plot of the <span 
class="ectt-1200">smmObjectiveFxn </span>function and the parameter estimates. The contour plot
shows equally spaced isoquants of the <span 
class="ectt-1200">smmObjectiveFxn </span>function, i.e. the pairs of <img 
src="SolvingMicroDSOPs442x.svg" alt="ρ  " class="math";align="absmiddle"> and <img 
src="SolvingMicroDSOPs443x.svg" alt="ℶ  " class="math";align="absmiddle">
which lead to the same deviations between simulated and empirical medians (equivalent
values of equation (<a 
href="#x1-19005r42">42<!--tex4ht:ref: eq:StructEstim --></a>)). Interestingly, there is a large rather ﬂat region; or, more
formally speaking, there exists a broad set of parameter pairs which leads to similar
simulated wealth to income ratios. Intuitively, the ﬂatter and larger is this region,
the harder it is for the structural estimation procedure to precisely identify the
parameters.
  <h3 class="sectionHead"><span class="titlemark">7  </span> <a 
 id="x1-220007"></a>Conclusion</h3>
<!--l. 2647--><p class="noindent" >There are many choices that can be made for solving microeconomic dynamic stochastic
optimization problems. The set of techniques, and associated programs, described in these
notes represents an approach that I have found to be powerful, ﬂexible, and eﬃcient, but other
problems may require other techniques. For a much broader treatment of many of the issues
considered here, see Judd (<span 
class="ecbx-1200">?</span>).
<!--l. 2650--><p class="indent" >  <a 
 id="PlotContourMedianStrEst"></a> <div class="figure" 
>
                                                                                     
                                                                                     
<a 
 id="x1-2200117"></a>
                                                                                     
                                                                                     
<!--l. 2652--><p class="noindent" > <img 
src="./Figures/SMMcontour-.svg" alt="PIC"  
style="width:96.76%">
<figcaption class="caption" ><span class="id">Figure 17: </span><span  
class="content">Contour Plot (larger values are shown lighter) with <img 
src="SolvingMicroDSOPs444x.svg" alt="{ρ,ℶ } " class="math";align="absmiddle"> Estimates (red
dot).</span></figcaption><!--tex4ht:label?: x1-2200117 -->                                                                                   <span 
class="ecrm-0600">{ﬁg:PlotContourMedianStrEst}</span>
                                                                                     
                                                                                     
  </div>
                                                                                     
                                                                                     
  <div  
class="centerline">                                                                      <span 
class="ecrm-2074">Appendices</span>                            </div>
  <h3 class="sectionHead"><span class="titlemark">A  </span> <a 
 id="x1-23000A"></a>Further Details on SCF Data</h3>                                                     <span 
class="ecrm-0600">{app:SCFdata}</span>
<!--l. 2665--><p class="noindent" >Data used in the estimation is constructed using the SCF 1992, 1995, 1998,
2001 and 2004 waves. The deﬁnition of wealth is net worth including housing
wealth, but excluding pensions and social securities. The data set contains
only households whose heads are aged 26-60 and excludes singles, following
Cagetti (<span 
class="ecbx-1200">?</span>).<span class="footnote-mark"><a 
href="SolvingMicroDSOPs22.html#fn21x0"><sup class="textsuperscript">21</sup></a></span><a 
 id="x1-23001f21"></a>  
Furthermore, the data set contains only households whose heads are college graduates. The
total sample size is 4,774.
<!--l. 2667--><p class="indent" >  In the waves between 1995 and 2004 of the SCF, levels of <span 
class="ecti-1200">normal </span>income are reported. The
question in the questionnaire is &#x0022;About what would your income have been if it had been a
normal year?&#x0022; We consider the level of normal income as corresponding to the model’s
theoretical object <img 
src="SolvingMicroDSOPs445x.svg" alt="P  " class="math";align="absmiddle">, permanent noncapital income. Levels of normal income are not
reported in the 1992 wave. Instead, in this wave there is a variable which reports whether
the level of income is normal or not. Regarding the 1992 wave, only observations
which report that the level of income is normal are used, and the levels of income of
remaining observations in the 1992 wave are interpreted as the levels of permanent
income.
<!--l. 2679--><p class="indent" >  Normal income levels in the SCF are before-tax ﬁgures. These before-tax permanent income
ﬁgures must be rescaled so that the median of the rescaled permanent income of each age
group matches the median of each age group’s income which is assumed in the simulation.
This rescaled permanent income is interpreted as after-tax permanent income. This rescaling
is crucial since in the estimation empirical proﬁles are matched with simulated ones which are
generated using after-tax permanent income (remember the income process assumed in the
main text). Wealth / permanent income ratio is computed by dividing the level of
wealth by the level of (after-tax) permanent income, and this ratio is used for the
estimation.<span class="footnote-mark"><a 
href="SolvingMicroDSOPs23.html#fn22x0"><sup class="textsuperscript">22</sup></a></span><a 
 id="x1-23003f22"></a>  
                                                                                     
                                                                                     
  <h3 class="likesectionHead"><a 
 id="x1-24000"></a>References</h3>
<!--l. 4--><p class="noindent" >
   
</body> 
</html>
                                                                                     


