(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



ClearAll["Global`*"];
SetDirectory[NotebookDirectory[]];
(*<<Combinatorica`*)
SeedRandom[100]
Off[General::"spell1"]; 
Off[InterpolatingFunction::"dmval"];


<<setup_ConsFn.m               (* Loading parameters and routines to solve for the age-varying consumption functions *)


<<setup_Sim.m                      (*Loading parameters and routines to compute simulated medians*)


<<setup_Estimation.m      (* Loading "GapEmpiricalSimulatedMedians" function *)


<<SCFdata.m                           (* Loading SCF data *)


VerboseOutput=True;
T0=SessionTime[];
ConstructShockDistribution;  (* Constructs shocks for each agent, function defined in setup_Sim.m *) 
ConstructSimShocks;                    (* Constructs shocks for each agent at each time, function defined in setup_Sim.m  *)
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
(* Around 0.12 minutes for simulating 10000 people under the new analytical method. *)


VerboseOutput=False;
{\[Rho]Min,\[Rho]Guess,\[Rho]Max,\[Bet]Min,\[Bet]Guess,\[Bet]Max}   = {2,4,8,0.85,0.98,1.05};    
(* Boundaries of the search region *)


{\[Rho],\[Bet]}={\[Rho]Min,\[Bet]Min+(3-1)*(\[Bet]Max-\[Bet]Min)/(10-1)}
(* This is a parameter pair far away from the optimum *)
ManipulateOption=True;


TStart1=SessionTime[]; 
Construct\[ScriptC]FuncLife[\[Rho],\[Bet]];   (* Constructs interpolated consumption functions *)
TEnd1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (TEnd1 - TStart1)/60];];


(* The automatic one from interpolation is \[Chi]Interp[\[Mu], PeriodsUntilT]; *)
(* The automatic one from interpolation, plus a mannual extrapolation, is \[Chi][\[Mu], PeriodsUntilT]. *)
(* Here we define the mannual generated cubic splines \[Chi]GPU[\[Mu], PeriodsUntlT]. *)
\[Chi]GPU[\[Mu]_, PeriodsUntlT_]:=Block[{\[Mu]2, \[Mu]3, \[Mu]4, \[Mu]5, \[Mu]6, \[Mu]7, \[Chi]This}
,
{\[Mu]2, \[Mu]3, \[Mu]4, \[Mu]5, \[Mu]6, \[Mu]7}=Table[\[Mu]LifeGrids[[ PeriodsUntlT+1, i]], {i, 2, 7}];
i=Piecewise[{
{1, \[Mu]<\[Mu]2}
, {2,\[Mu]2<=\[Mu]<\[Mu]3}
, {3,\[Mu]3<=\[Mu]<\[Mu]4}
, {4,\[Mu]4<=\[Mu]<\[Mu]5}
, {5,\[Mu]5<=\[Mu]<\[Mu]6}
, {6,\[Mu]6<=\[Mu]<\[Mu]7}
, {7,\[Mu]7<=\[Mu]}
 }];
{b0, b1, b2, b3}=Table[\[Chi]\[Mu]LifeCoeffs[[ PeriodsUntlT+1, i, j]],  {j, 1, 4}]
;
\[Chi]This= b0 + b1*\[Mu] +b2*\[Mu]^2 +b3*\[Mu]^3;
Return[\[Chi]This];
];


(* This confirms that all three functions look like the same. *)
If[ManipulateOption==True, 
Manipulate[ 
Show[
Plot[{\[Chi]Interp[x, PeriodsUntilT]
, \[Chi][x, PeriodsUntilT], \[Chi]GPU[x, PeriodsUntilT]}, {x, \[Mu]LifeGrids[[ PeriodsUntilT+1, 1]]-20, \[Mu]LifeGrids[[ PeriodsUntilT+1, -1]]+20}]
, ListPlot[Table[{\[Mu]LifeGrids[[ PeriodsUntilT+1, i]], \[Chi]DataLifeGrids[[ PeriodsUntilT+1, i, 2]]}, {i,2, 7}]
, PlotMarkers->{Automatic,Medium}]
], {PeriodsUntilT, 1, PeriodsToSolve-1, 1}]
]


(* As shown in the Manipulate command, the three functions are identical up to 10^(-8) significance level. *)
If[ManipulateOption==True,
Manipulate[ 
Show[
Plot[{\[Chi]Interp[x, PeriodsUntilT]-\[Chi][x, PeriodsUntilT],\[Chi]Interp[x, PeriodsUntilT]-\[Chi]GPU[x, PeriodsUntilT]}, {x, \[Mu]LifeGrids[[ PeriodsUntilT+1, 1]]-20, \[Mu]LifeGrids[[ PeriodsUntilT+1, -1]]+20}
, PlotRange->{-10^(-DigitSignificance),  10^(-DigitSignificance)}]
]
, {DigitSignificance, 5,10, 1}
, {PeriodsUntilT, 1, PeriodsToSolve-1, 1}]
]


OptionConsFnInSim={"cVecMoM", "\[Chi]Interp"};
UseGPU = False;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
(* Another option is to specify that 
OptionConsFnInSim={"cVecMoM","\[Chi]Listable"}
, which will give you the same results, but with 0.2 minutes for simulations. 
*)
(*
OptionConsFnInSim={"cVecMoM","\[Chi]Listable"};
UseGPU = False;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
*)


UseGPU =True;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];


If[ManipulateOption==True,
Manipulate[ 
{
Max[Abs[mtSimMatGPU[[Period]]-mtSimMatCPU[[Period]]]]
, Max[Abs[ctSimMatGPU[[Period]]-ctSimMatCPU[[Period]]]]
, Max[Abs[atSimMatGPU[[Period]]-atSimMatCPU[[Period]]]]
, Max[Abs[wtSimMatGPU[[Period]]-wtSimMatCPU[[Period]]]]
}
, {Period, 26-25, 60-25, 1}]
]


ClearAll[mtSimMat, mtSimMatCPU, mtSimMatGPU
, ctSimMat, ctSimMatCPU, ctSimMatGPU
, atSimMat, atSimMatCPU, atSimMatGPU
, wtSimMat, wtSimMatCPU, wtSimMatGPU
];


{\[Rho],\[Bet]}={\[Rho]Guess,\[Bet]Max}
(* This is a parameter pair far away from the optimum *)
ManipulateOption=False;


TStart1=SessionTime[]; 
Construct\[ScriptC]FuncLife[\[Rho],\[Bet]];   (* Constructs interpolated consumption functions *)
TEnd1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (TEnd1 - TStart1)/60];];


(* The automatic one from interpolation is \[Chi]Interp[\[Mu], PeriodsUntilT]; *)
(* The automatic one from interpolation, plus a mannual extrapolation, is \[Chi][\[Mu], PeriodsUntilT]. *)
(* Here we define the mannual generated cubic splines \[Chi]GPU[\[Mu], PeriodsUntlT]. *)
\[Chi]GPU[\[Mu]_, PeriodsUntlT_]:=Block[{\[Mu]2, \[Mu]3, \[Mu]4, \[Mu]5, \[Mu]6, \[Mu]7, \[Chi]This}
,
{\[Mu]2, \[Mu]3, \[Mu]4, \[Mu]5, \[Mu]6, \[Mu]7}=Table[\[Mu]LifeGrids[[ PeriodsUntlT+1, i]], {i, 2, 7}];
i=Piecewise[{
{1, \[Mu]<\[Mu]2}
, {2,\[Mu]2<=\[Mu]<\[Mu]3}
, {3,\[Mu]3<=\[Mu]<\[Mu]4}
, {4,\[Mu]4<=\[Mu]<\[Mu]5}
, {5,\[Mu]5<=\[Mu]<\[Mu]6}
, {6,\[Mu]6<=\[Mu]<\[Mu]7}
, {7,\[Mu]7<=\[Mu]}
 }];
{b0, b1, b2, b3}=Table[\[Chi]\[Mu]LifeCoeffs[[ PeriodsUntlT+1, i, j]],  {j, 1, 4}]
;
\[Chi]This= b0 + b1*\[Mu] +b2*\[Mu]^2 +b3*\[Mu]^3;
Return[\[Chi]This];
];


(* This confirms that all three functions look like the same. *)
If[ManipulateOption==True, 
Manipulate[ 
Show[
Plot[{\[Chi]Interp[x, PeriodsUntilT]
, \[Chi][x, PeriodsUntilT], \[Chi]GPU[x, PeriodsUntilT]}, {x, \[Mu]LifeGrids[[ PeriodsUntilT+1, 1]]-20, \[Mu]LifeGrids[[ PeriodsUntilT+1, -1]]+20}]
, ListPlot[Table[{\[Mu]LifeGrids[[ PeriodsUntilT+1, i]], \[Chi]DataLifeGrids[[ PeriodsUntilT+1, i, 2]]}, {i,2, 7}]
, PlotMarkers->{Automatic,Medium}]
], {PeriodsUntilT, 1, PeriodsToSolve-1, 1}]
]


(* As shown in the Manipulate command, the three functions are identical up to 10^(-8) significance level. *)
If[ManipulateOption==True,
Manipulate[ 
Show[
Plot[{\[Chi]Interp[x, PeriodsUntilT]-\[Chi][x, PeriodsUntilT],\[Chi]Interp[x, PeriodsUntilT]-\[Chi]GPU[x, PeriodsUntilT]}, {x, \[Mu]LifeGrids[[ PeriodsUntilT+1, 1]]-20, \[Mu]LifeGrids[[ PeriodsUntilT+1, -1]]+20}
, PlotRange->{-10^(-DigitSignificance),  10^(-DigitSignificance)}]
]
, {DigitSignificance, 5,10, 1}
, {PeriodsUntilT, 1, PeriodsToSolve-1, 1}]
]


OptionConsFnInSim={"cVecMoM", "\[Chi]Interp"};
UseGPU = False;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
(* Another option is to specify that 
OptionConsFnInSim={"cVecMoM","\[Chi]Listable"}
, which will give you the same results, but with 0.2 minutes for simulations. 
*)
(*
OptionConsFnInSim={"cVecMoM","\[Chi]Listable"};
UseGPU = False;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
*)


UseGPU =True;
VerboseOutput=True;
{\[Rho],\[Bet]}
T0=SessionTime[];
GapEmpiricalSimulatedMedians[\[Rho],\[Bet]]
T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];


If[ManipulateOption==True,
Manipulate[ 
{
Max[Abs[mtSimMatGPU[[Period]]-mtSimMatCPU[[Period]]]]
, Max[Abs[ctSimMatGPU[[Period]]-ctSimMatCPU[[Period]]]]
, Max[Abs[atSimMatGPU[[Period]]-atSimMatCPU[[Period]]]]
, Max[Abs[wtSimMatGPU[[Period]]-wtSimMatCPU[[Period]]]]
}
, {Period, 26-25, 60-25, 1}]
]


ClearAll[mtSimMat, mtSimMatCPU, mtSimMatGPU
, ctSimMat, ctSimMatCPU, ctSimMatGPU
, atSimMat, atSimMatCPU, atSimMatGPU
, wtSimMat, wtSimMatCPU, wtSimMatGPU
];


ManipulateOption=False;


\[Rho]TrialVec=Table[\[Rho]Min+(i-1)*(\[Rho]Max-\[Rho]Min)/(10-1), {i, 1, 10}];
 \[Bet]TrialVec=Table[\[Bet]Min+(i-1)*(\[Bet]Max-\[Bet]Min)/(10-1), {i, 1, 10}];


UseGPU=False;
{GapMatCPU, TimeConsFnMatCPU, TimeSimulateMatCPU, TimeGapCompMatCPU, TimeTotalMatCPU}=Table[Null, {k, 1, 5}, {i, 1, 10}, {j, 1, 10}];


For[\[Rho]i=1, \[Rho]i<=10, \[Rho]i++,
For[\[Bet]j=1, \[Bet]j<=10, \[Bet]j++,
{\[Rho],\[Bet]}={\[Rho]TrialVec[[\[Rho]i]],\[Bet]TrialVec[[\[Bet]j]]};
VerboseOutput=False;
T0=SessionTime[];
GapMatCPU[[\[Rho]i, \[Bet]j]]=GapEmpiricalSimulatedMedians[\[Rho],\[Bet]];

ClearAll[mtSimMat, mtSimMatCPU, mtSimMatGPU
, ctSimMat, ctSimMatCPU, ctSimMatGPU
, atSimMat, atSimMatCPU, atSimMatGPU
, wtSimMat, wtSimMatCPU, wtSimMatGPU
];

T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
TimeConsFnMatCPU[[\[Rho]i, \[Bet]j]]=(TEnd1 - TStart1)/60;
TimeSimulateMatCPU[[\[Rho]i,\[Bet]j]]=(TEnd2 - TStart2)/60;
TimeGapCompMatCPU[[\[Rho]i, \[Bet]j]]=(TEnd3 - TStart3)/60;
TimeTotalMatCPU[[\[Rho]i, \[Bet]j]]=(T1 - T0)/60;
Clear[\[Rho],\[Bet]];
];
Print["Finished for i= ", \[Rho]i];
];


UseGPU= True;
{GapMatGPU, TimeConsFnMatGPU, TimeSimulateMatGPU, TimeGapCompMatGPU, TimeTotalMatGPU}=Table[Null, {k, 1, 5}, {i, 1, 10}, {j, 1, 10}];
For[\[Rho]i=1, \[Rho]i<=10, \[Rho]i++,
For[\[Bet]j=1, \[Bet]j<=10, \[Bet]j++,
{\[Rho],\[Bet]}={\[Rho]TrialVec[[\[Rho]i]],\[Bet]TrialVec[[\[Bet]j]]};
VerboseOutput=False;
T0=SessionTime[];
GapMatGPU[[\[Rho]i, \[Bet]j]]=GapEmpiricalSimulatedMedians[\[Rho],\[Bet]];

ClearAll[mtSimMat, mtSimMatCPU, mtSimMatGPU
, ctSimMat, ctSimMatCPU, ctSimMatGPU
, atSimMat, atSimMatCPU, atSimMatGPU
, wtSimMat, wtSimMatCPU, wtSimMatGPU
];

T1=SessionTime[];
If[VerboseOutput==True, Print["Time used (min): ", (T1 - T0)/60];];
TimeConsFnMatGPU[[\[Rho]i, \[Bet]j]]=(TEnd1 - TStart1)/60;
TimeSimulateMatGPU[[\[Rho]i,\[Bet]j]]=(TEnd2 - TStart2)/60;
TimeGapCompMatGPU[[\[Rho]i, \[Bet]j]]=(TEnd3 - TStart3)/60;
TimeTotalMatGPU[[\[Rho]i, \[Bet]j]]=(T1 - T0)/60;
Clear[\[Rho],\[Bet]];
];
Print["Finished for i= ", \[Rho]i];
];


TinySmall=10^(-6);
ListLinePlot[Flatten[GapMatCPU/GapMatGPU, 1], PlotRange->{1-TinySmall, 1+TinySmall}] 


Map[ListLinePlot[Flatten[#, 1], PlotRange->All]  &, {TimeConsFnMatCPU/TimeConsFnMatGPU
,TimeSimulateMatCPU/TimeSimulateMatGPU
, TimeGapCompMatCPU/TimeGapCompMatGPU
, TimeTotalMatCPU/TimeTotalMatGPU}
]


PlotGapCPUVsGPU=ListLinePlot[Flatten[GapMatCPU/GapMatGPU, 1], PlotRange->{1-TinySmall, 1+TinySmall}] 
PlotTimeConsFnCPUVsGPU=ListLinePlot[Flatten[TimeConsFnMatCPU/TimeConsFnMatGPU, 1], PlotRange->All, PlotLabel->"TimeConsFn: CPU/PU"] 
PlotTimeSimulateCPUVsGPU=ListLinePlot[Flatten[TimeSimulateMatCPU/TimeSimulateMatGPU, 1], PlotRange->All, PlotLabel->"TimeSimulate: CPU/GPU"] 
PlotTimeGapComputeCPUVsGPU=ListLinePlot[Flatten[TimeGapCompMatCPU/TimeGapCompMatGPU, 1], PlotRange->All, PlotLabel->"TimeGapCompute: CPU/GPU"] 
PlotTimeTotalCPUVsGPU=ListLinePlot[Flatten[TimeTotalMatCPU/TimeTotalMatGPU, 1], PlotRange->All, PlotLabel->"TimeTotal: CPU/GPU"] 

Export["../../../Figures/PlotGapCPUVsGPU.pdf",PlotGapCPUVsGPU];
Export["../../../Figures/PlotTimeConsFnCPUVsGPU.pdf",PlotTimeConsFnCPUVsGPU];
Export["../../../Figures/PlotTimeSimulateCPUVsGPU.pdf",PlotTimeSimulateCPUVsGPU];
Export["../../../Figures/PlotTimeGapComputeCPUVsGPU.pdf",PlotTimeGapComputeCPUVsGPU];
Export["../../../Figures/PlotTimeTotalCPUVsGPU.pdf",PlotTimeTotalCPUVsGPU];




